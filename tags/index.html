<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="还是原来的那个CC吗...">
<meta name="theme-color" content="#000">
<title>ForeverCC&#39;s blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1702465892935">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>ForeverCC&#39;s blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">还是原来的CC吗？</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 文章
                </a>
              
            </li>
          
            
            
              
            
            
            <li class="nav-item nav-item-active">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
            
            
              
            
            
            <li class="nav-item ">
              
              
                <a href="/post/tui-jian" target="_self">
                  <i class="fa fa-globe"></i> 推荐网站
                </a>
              
            </li>
          
            
            
              
            
            
            <li class="nav-item ">
              
              
                <a href="https://blackwhite0601.github.io/" target="_self">
                  <i class="fa fa-globe"></i> 我的小站
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  pisces">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">ForeverCC</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">伊蕾娜敲可爱的(*^▽^*)</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">19</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'pisces';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box box-shadow-wrapper">
          <section class="section tags-section bg-color posts-expand">
            <div class="tags-box">
  <div class="tag-cloud-title language" data-lan="cloud-tags" data-count="4">
    非常好！目前共计 4 个标签，继续努力！
  </div>
  <div class="tag-cloud-list" id="tags">
    
      
      
        
      
        
          
            
      
        
          
            
      
        
          
            
      
        
          
            
      
        
          
            
      
        
          
            
      
        
          
            
      
        
          
            
      
        
          
        
      
        
          
        
      
        
          
            
      
        
          
        
      
        
          
            
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            
      
        
      
        
          
            
      
        
      
      <a class="cloud-tag" href="https://yydcc-blog.github.io/tag/6CprhTvCM/" rel="12">C++</a>
    
      
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            
      
        
          
            
      
        
          
        
      
        
          
            
      
        
          
        
      
        
          
        
      
        
          
            
      
        
          
        
      
        
          
        
      
        
      
        
          
        
      
        
      
      <a class="cloud-tag" href="https://yydcc-blog.github.io/tag/lXxnjkxcU/" rel="4">颓废</a>
    
      
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            
      
        
          
        
      
        
          
        
      
        
          
        
      
        
      
        
          
        
      
        
      
      <a class="cloud-tag" href="https://yydcc-blog.github.io/tag/ANYYmWV2G/" rel="1">游记</a>
    
      
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
            
      
        
          
        
      
        
      
        
          
        
      
        
      
      <a class="cloud-tag" href="https://yydcc-blog.github.io/tag/QyiIIUN2v/" rel="1">题解</a>
    
  </div>
</div>
<script>

  let fontStart = 12, fontEnd = 30, colorStart = '#666', colorEnd = '#000';
  let tags = document.querySelector('#tags').children;
  let counts = [];
  for(let i = 0; i < tags.length; i++) {
    counts.push(tags[i].rel);
  }
  let lowest = Math.min.apply(null,counts), highest = Math.max.apply(null,counts);;
  let range = highest - lowest;
  if (range === 0) {
    range = 1;
  }
  let fontIncr, colorIncr;
  fontIncr = (fontEnd - fontStart) / range;
  
  let sColorArr = toRGB(colorStart), eColorArr = toRGB(colorEnd);

  for(let i = 0; i < tags.length; i++) {
    let disCount = tags[i].rel - lowest;
    let fontSize = fontStart + disCount * fontIncr;
    let style = 'font-size: ' + fontSize + 'px;';
    let arr = [];
    for(let c = 0; c < sColorArr.length; c++) {
      if (disCount === 0) {
        disCount = 1;
      }
      let val = (sColorArr[c] - eColorArr[c]) / range * disCount;
      if (val >= 100) {
        val = eColorArr[c];
      } else if (val <= 0) {
        val = sColorArr[c];
      }
      arr[c] = Math.floor(val);
    }
    style += 'color: ' + toHex(arr);
    tags[i].style = style;
  }

  function toRGB(code) {
    if (code.length === 4) {
      code = code.replace(/(\w)(\w)(\w)/gi, "\$1\$1\$2\$2\$3\$3");
    }
    var hex = /(\w{2})(\w{2})(\w{2})/.exec(code);
    return [parseInt(hex[1], 16), parseInt(hex[2], 16), parseInt(hex[3], 16)];
  }

  function toHex(ary) {
    return "#" + ((1 << 24) + (ary[0] << 16) + (ary[1] << 8) + ary[2]).toString(16).slice(1);
  }

</script>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Belongs to <a href="https://blackwhite0601.github.io/" target="_blank">ForeverCC</a>
    </div>
  </footer>
  
    
        <div class="pisces back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="\media\images\custom-bgImg.png" />
              </div>
              
                
                  
                    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'histoire'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
                      
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "不要离开我QWQ";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/zi-fu-chuan-suan-fa-zong-jie/"" data-c="
          &lt;h1 id=&#34;字符串&#34;&gt;字符串&lt;/h1&gt;
&lt;h2 id=&#34;part-0前言&#34;&gt;Part 0:前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;**NK&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;part-1字符串的存储和基本操作&#34;&gt;Part 1：字符串的存储和基本操作&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt; 都行。&lt;/p&gt;
&lt;p&gt;主要使用 &lt;code&gt;char&lt;/code&gt;，但 &lt;code&gt;string&lt;/code&gt; 拥有强大的 &lt;code&gt;STL&lt;/code&gt;，这里举几个例子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s.length() / s.size()&lt;/code&gt;：长度/大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s.find(char c[],int begin=0)&lt;/code&gt;：从位置 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;begin&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;（不写默认为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;） 开始查找字符（串） &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 并返回第一个出现的位置。没找到时返回 &lt;code&gt;s.npos&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s.erase(pos,n)&lt;/code&gt;：删除从pos开始的n个字符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s.erase(pos)&lt;/code&gt;：删除pos处的一个字符。（pos是string类型的迭代器，也就是 &lt;code&gt;pos=s.begin()+位置&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;part-2kmp算法&#34;&gt;Part 2：KMP算法&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3375&#34;&gt;luogu P3375 【模板】KMP&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;求模式串在主串中的出现情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果直接暴力匹配字符串肯定是不行的。&lt;/p&gt;
&lt;p&gt;但是如果对于每次失配之后，不从头重新开始枚举，而是根据已经得知的数据，从某个特定的位置开始匹配，就可以啦。&lt;/p&gt;
&lt;p&gt;所以我们定义 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;kmp_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为匹配到模式串的第 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 位，失配时跳到哪一位。（其中 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;kmp_0=kmp_1=1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，因为此时只能跳到第一位了awa）&lt;/p&gt;
&lt;p&gt;所以匹配就很简单了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;t=0;
for(int i=1;a[i];i++){
	while(t&amp;amp;&amp;amp;b[t+1]!=a[i])t=kmp[t];//若失配则跳到上一个位置
	if(b[t+1]==a[i])t++;//匹配成功
	if(t==strlen(b+1)){//匹配完成
		printf(&amp;quot;%d\n&amp;quot;,i-strlen(b+1)+1);
		t=kmp[t];
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们要怎么求这个 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;kmp&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 呢？&lt;/p&gt;
&lt;p&gt;可以考虑自己匹配自己。（也就是先和自己跑一遍匹配）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;t=0;
for(int i=2;b[i];i++){
	while(t&amp;amp;&amp;amp;b[i]!=b[t+1])t=kmp[t];
	if(b[t+1]==b[i])t++;
	kmp[i]=t;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后...就没了qAq。&lt;/p&gt;
&lt;h2 id=&#34;part-3字典树&#34;&gt;Part 3：字典树&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8306&#34;&gt;luogu P8306 【模板】字典树&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快，省空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字典树就是将大量字符串转化为树形结构。&lt;/p&gt;
&lt;p&gt;定义 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;t_{i,j}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.9011879999999999em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示当前节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的字符为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根节点不包含字符，除根节点外每一个节点都只包含一个字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个节点的所有子节点包含的字符都不相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;part-31插入操作&#34;&gt;Part 3.1：插入操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void add(char s[]){
	int p=0;
	for(int i=0;s[i];i++){
		int v=getnum(s[i]);//为s[i]的值
		if(!t[p][v])t[p][v]=++id;//id为节点编号
		p=t[p][v];//迭代
		cnt[p]++;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;part-32查询操作&#34;&gt;Part 3.2：查询操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int find(char s[]){
	int p=0;
	for(int i=0;s[i];i++){
		int v=getnum(s[i]);
		if(!t[p][v])return 0;//没查到
		p=t[p][v];
	}
	return cnt[p];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;part-4ac自动机&#34;&gt;Part 4：AC自动机&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在字典树上跑KMP。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在KMP中我们用 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;kmp_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示失配后跳到哪一位。&lt;/p&gt;
&lt;p&gt;那我们为什么不在字典树上构建一个类似的数组以解决多模式串匹配呢呢？&lt;/p&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;插入（和字典树一样awa）：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void add(char *s){
	int u=0;
	for(int i=0;s[i];i++){
		int v=s[i]-&#39;a&#39;;
		if(!t[u][v])t[u][v]=++cnt;
		u=t[u][v];
	}
	val[u]++;//统计数量
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;构建 fail 数组：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void build(){
	queue&amp;lt;int&amp;gt; q;//因为要先处理出父亲节点的fail，所以用bfs
	for(int i=0;i&amp;lt;26;i++)
		if(t[0][i])fail[t[0][i]]=0,q.push(t[0][i]);//与根节点相连的统一指向根节点
	while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=0;i&amp;lt;26;i++)
        if(t[u][i])fail[t[u][i]]=t[fail[u]][i],q.push(t[u][i]);//若有，fail则为其父亲节点失配后下一个为i的点
        else t[u][i]=t[fail[u]][i];//不然，将其相连
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;匹配：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int query(char *s){
    int len=strlen(s);
	int u=0,ans=0;
    for(int i=0;i&amp;lt;len;i++){
        u=t[u][s[i]-&#39;a&#39;];//跳
        for(int t=u;t&amp;amp;&amp;amp;~val[t];t=fail[t])ans+=val[t],val[t]=-1;
      //当此节点存在同时其cnt未被遍历
      //将答案加上所搜索的字符串中所包含的该单词数
      //标记
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;part-5后缀数组&#34;&gt;Part 5：后缀数组&lt;/h2&gt;
&lt;p&gt;首先，求后缀的排名 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;rank_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &amp;amp; 这个后缀是第几名&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sa_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;rank_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示第 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个后缀的排名。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sa_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示第 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 名是哪个后缀。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以该怎么做呢？&lt;/p&gt;
&lt;h3 id=&#34;part-51暴力快排&#34;&gt;Part 5.1：暴力快排&lt;/h3&gt;
&lt;p&gt;暴力存储所有后缀再排序，时间复杂度 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^2logn)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（其中快排 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlogn)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，字符串比较 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;h3 id=&#34;part-52倍增快排&#34;&gt;Part 5.2：倍增+快排&lt;/h3&gt;
&lt;p&gt;不说了，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlog2n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&#34;part-53倍增基数排序&#34;&gt;Part 5.3：倍增+基数排序&lt;/h3&gt;
&lt;p&gt;主要讲这个 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;？&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nlogn)？&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的算法。&lt;/p&gt;
&lt;p&gt;倍增，每次通过两个关键字进行基数排序。&lt;/p&gt;
&lt;p&gt;最后统计排名，并考虑并列的情况。&lt;/p&gt;
&lt;p&gt;当排出 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 名了后退出即可。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3809&#34;&gt;luogu P3809 【模板】后缀排序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;part-54求height&#34;&gt;Part 5.4：求height&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;证明：h[i]&amp;gt;=h[i-1]-1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;s&gt;大佬的证明：&lt;/s&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先我们不妨设第i-1个字符串按排名来的前面的那个字符串是第k个字符串，注意k不一定是i-2，因为第k个字符串是按字典序排名来的i-1前面那个，并不是指在原字符串中位置在i-1前面的那个第i-2个字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这时，依据height[]的定义，第k个字符串和第i-1个字符串的公共前缀自然是height[rk[i-1]]，现在先讨论一下第k+1个字符串和第i个字符串的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;第一种情况，第k个字符串和第i-1个字符串的首字符不同，那么第k+1个字符串的排名既可能在i的前面，也可能在i的后面，但没有关系，因为height[rk[i-1]]就是0了呀，那么无论height[rk[i]]是多少都会有height[rk[i]]&amp;gt;=height[rk[i-1]]-1，也就是h[i]&amp;gt;=h[i-1]-1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;第二种情况，第k个字符串和第i-1个字符串的首字符相同，那么由于第k+1个字符串就是第k个字符串去掉首字符得到的，第i个字符串也是第i-1个字符串去掉首字符得到的，那么显然第k+1个字符串要排在第i个字符串前面。同时，第k个字符串和第i-1个字符串的最长公共前缀是height[rk[i-1]]，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;那么自然第k+1个字符串和第i个字符串的最长公共前缀就是height[rk[i-1]]-1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;到此为止，第二种情况的证明还没有完，我们可以试想一下，对于比第i个字符串的排名更靠前的那些字符串，谁和第i个字符串的相似度最高（这里说的相似度是指最长公共前缀的长度）？显然是排名紧邻第i个字符串的那个字符串了呀，即sa[rank[i]-1]。但是我们前面求得，有一个排在i前面的字符串k+1，LCP(rk[i],rk[k+1])=height[rk[i-1]]-1;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;又因为height[rk[i]]=LCP(i,i-1)&amp;gt;=LCP(i,k+1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;所以height[rk[i]]&amp;gt;=height[rk[i-1]]-1，也即h[i]&amp;gt;=h[i-1]-1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N=1e6+5;
int k=1,n,st[256],rank0[N&amp;lt;&amp;lt;1],cnt[N],tmp[N],sa[N],rank1[N],height[N];
char str1[N];
int main(){
	scanf(&amp;quot;%s&amp;quot;,str1+1);
	n=strlen(str1+1);
	for(int i=1;i&amp;lt;=n;i++)st[str1[i]]=1;//浅浅排一下第一个字符
	for(int i=1;i&amp;lt;=255;i++)st[i]+=st[i-1];
	for(int i=1;i&amp;lt;=n;i++)rank0[i]=st[str1[i]];
	for(int p=1;k!=n;p=p*2){//倍增直到所有后缀都排出名来
		memset(cnt,0,sizeof cnt);//按第二关键字排序
		for(int i=1;i&amp;lt;=n;i++)cnt[rank0[i+p]]++;
		for(int i=1;i&amp;lt;=n;i++)cnt[i]+=cnt[i-1];//前缀和
		for(int i=n;i&amp;gt;=1;i--)tmp[cnt[rank0[i+p]]--]=i;//第二关键字排序结果
		memset(cnt,0,sizeof cnt);//按第一关键字排序
		for(int i=1;i&amp;lt;=n;i++)cnt[rank0[i]]++;
		for(int i=1;i&amp;lt;=n;i++)cnt[i]+=cnt[i-1];//前缀和
		for(int i=n;i&amp;gt;=1;i--)sa[cnt[rank0[tmp[i]]]--]=tmp[i];//第一关键字排序结果，也就是最终排序的结果sa[i]
		k=1;
		rank0[sa[1]]=k;//排名，第一个肯定为1
		memcpy(rank1,rank0,sizeof(rank1));
		for(int i=2;i&amp;lt;=n;i++){
			if(!(rank1[sa[i]]==rank1[sa[i-1]]&amp;amp;&amp;amp;rank1[sa[i]+p]==rank1[sa[i-1]+p]))k++;//检测两个关键字是否相同，若相同则排名相同
			rank0[sa[i]]=k;
		}
	}
  	k=0;//开始求height
	for(int i=1;i&amp;lt;=n;i++){
		if(rank0[i]==1)continue;//第一名height为0
		if(k)k--;//h[i]&amp;gt;=h[i-1]-1;
		while(str1[i+k]==str1[sa[rank0[i]-1]+k])k++;
		height[rank0[i]]=k;
	}
	for(int i=1;i&amp;lt;=n;i++)
		printf(&amp;quot;%d%c&amp;quot;,sa[i],(i==n)?&#39;\n&#39;:&#39; &#39;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;part-6后缀自动机&#34;&gt;Part 6：后缀自动机&lt;/h2&gt;
&lt;p&gt;自己学去，劳资不会。&lt;/p&gt;
">字符串算法总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/2023afo-ji-nian-afo-liao-zai-zuo-shi-me-you-mei-you-kong-ke-yi-chong-xin-zai-lai-ma/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;这是一位浙江OIer与他爱的OI的故事&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;part-0在太阳西斜的这个日子里&#34;&gt;Part 0：在太阳西斜的这个日子里&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yydcc-blog.github.io//post-images/1697947153266.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这7年真是多谢你了...&lt;br&gt;
让我体验了许多美好...&lt;br&gt;
我留下了如同美梦一般的回忆 不过时间到了...&lt;br&gt;
最后我还想拜托你一件事...&lt;br&gt;
希望你可以把我忘掉...&lt;/p&gt;
&lt;p&gt;在自己AFO之前...&lt;br&gt;
心怀不想消失的愿望...&lt;br&gt;
希望让OI记住我...&lt;br&gt;
希望能留下羁绊...&lt;br&gt;
我这么希望着，又有什么不可以的吗...&lt;/p&gt;
&lt;h1 id=&#34;part-1置身繁杂人间&#34;&gt;Part 1：置身繁杂人间&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;梦开始的地方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;依稀记得自己接触OI还是在小学三年级，准备从&lt;code&gt;Scratch&lt;/code&gt;转型到&lt;code&gt;C++&lt;/code&gt;。&lt;br&gt;
找了许多机构培训，渐渐体会到最为一个OIer的乐趣。&lt;br&gt;
第一次打开自己的电脑，第一次打开IDE......许多场景仍记忆犹新。&lt;br&gt;
也是从那时开始，发现自己，已经深深爱上了OI。&lt;/p&gt;
&lt;p&gt;而学习OI中的乐趣不仅如此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次接触到自己的电脑，那时连自己的手机也没有，那第一部电脑从此陪伴了7年。&lt;/li&gt;
&lt;li&gt;交到许多朋友，有先辈也有后辈，也许他们比我在学校的同学，或许更重要吧...&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;part-2等这场比赛结束之后&#34;&gt;Part 2：等这场比赛结束之后&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;没有谁的人生是一帆风顺的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;竞赛，仍是学习&lt;code&gt;C++&lt;/code&gt;最大的用处之一。&lt;br&gt;
最初只是报名参加一些市级区级的比赛。（那时还有）&lt;br&gt;
即使失败了也不会那么的难过...&lt;br&gt;
直到&lt;br&gt;
2018年的那场初赛开始，我的精神被渐渐摧毁...&lt;/p&gt;
&lt;h2 id=&#34;part21noip2018-初赛&#34;&gt;Part2.1：NOIP2018-初赛&lt;/h2&gt;
&lt;p&gt;第一次参加CCF举办的比赛，有些紧张。&lt;br&gt;
但我任然很有信心，自己几个月的准备将在这一天展现出来。&lt;br&gt;
比赛地点在宁波诺丁汉大学，上午下午两场初赛都打了。&lt;br&gt;
回家的路上我还天真的以为自己能顺利通过。&lt;/p&gt;
&lt;p&gt;结果下来后，我崩溃了。&lt;br&gt;
也可能是那时心智还不成熟吧，我异常的狂暴。&lt;br&gt;
没有好好分析自己的错误，将错就错，这也直接导致了：&lt;/p&gt;
&lt;h2 id=&#34;part22csp2019-初赛&#34;&gt;Part2.2：CSP2019-初赛&lt;/h2&gt;
&lt;p&gt;算法学得越来越多，题目刷的越来越多。&lt;br&gt;
但我还是没有改掉粗心的老毛病。&lt;br&gt;
模拟赛中不知有多少次因没有去除&lt;code&gt;freopen&lt;/code&gt;前的&lt;code&gt;//&lt;/code&gt;或是***文件夹名字写错（这是重点...要考的...qAq）***而丢失大量分数。&lt;br&gt;
每次都是无能的发怒，将我的心彻底填满，没有一点理智。&lt;br&gt;
也是到初赛成绩出来后，发现自己的同龄人甚至后辈赶超了自己。&lt;br&gt;
愤怒逐渐变质，变成无尽的悲伤、沮丧、后悔。&lt;/p&gt;
&lt;p&gt;从那以后，我，再也没发过火...&lt;/p&gt;
&lt;h2 id=&#34;part23csp2020-初赛&#34;&gt;Part2.3：CSP2020-初赛&lt;/h2&gt;
&lt;p&gt;小升初不再可以通过竞赛加分了，改为摇号，不能自主选拔。&lt;/p&gt;
&lt;p&gt;说是幸运还是不幸好呢...升入了一个比较一般的学校。&lt;br&gt;
没有太大的文化课压力，使我能在OI上花更多的时间。&lt;br&gt;
俗话说，飞的越高，摔得越惨。&lt;/p&gt;
&lt;p&gt;如你们所料，这次初赛我仍未通过。&lt;br&gt;
我不再发怒，唯一能做的就是躲在被窝里哭泣。&lt;br&gt;
面对第三次失败，我已经再也受不了了。&lt;/p&gt;
&lt;h1 id=&#34;part-3不归之人与望眼欲穿的人们&#34;&gt;Part 3：不归之人与望眼欲穿的人们&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;从此改变，I need power。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;镇海中学，宁波OIer向往的地方。&lt;br&gt;
对于一个初中生，向往的便是可以说是镇海中学附属中学的蛟川书院了。&lt;br&gt;
我需要一个更有竞争力的环境来磨练自己，所以我放弃了寒暑假的大部分时间，只为锻炼自己，变得更强。&lt;br&gt;
这时回收过去，才发现，已经无法回头......&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yydcc-blog.github.io//post-images/1697948498073.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;part-4人人本着变强之名&#34;&gt;Part 4：人人本着变强之名&lt;/h1&gt;
&lt;h2 id=&#34;part-41变强&#34;&gt;Part 4.1：变强。&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;总有比你更强的人，而那个人总会在你的身边......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内卷，成为了学生口中常说的一个词。&lt;br&gt;
OI更是如此。&lt;br&gt;
你不卷，就会被别人超越。&lt;br&gt;
每当听到有人在谈论我不知道的算法时，巨大的压力便向我袭来。&lt;/p&gt;
&lt;h2 id=&#34;part-42变强&#34;&gt;Part 4.2：变强？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;总有人用着比你更高级的摸鱼方法，而那个人总会在你的身边......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这样一个环境中，摸鱼，反而成了常态。&lt;br&gt;
发泄压力，获得喜悦。&lt;br&gt;
我也是如此。&lt;/p&gt;
&lt;h2 id=&#34;part-43csp2021-j-开始&#34;&gt;Part 4.3：CSP2021-J 开始&lt;/h2&gt;
&lt;p&gt;这次是压线进的。&lt;br&gt;
以下是我当时写的游记：&lt;/p&gt;
&lt;h3 id=&#34;day-27&#34;&gt;Day -27：&lt;/h3&gt;
&lt;p&gt;今年复赛终于进了，压线两分。&lt;br&gt;
我觉得只要进了就好，没别的要求。&lt;br&gt;
S组差亿点点QWQ。&lt;/p&gt;
&lt;h3 id=&#34;day-26&#34;&gt;Day -26：&lt;/h3&gt;
&lt;p&gt;开始准备复赛。&lt;br&gt;
搞了一些网课什么的，模拟赛打一打。鱼摸一摸&lt;/p&gt;
&lt;h3 id=&#34;day-1-afternoon&#34;&gt;Day -1 afternoon：&lt;/h3&gt;
&lt;p&gt;逃了学校的两堂课，直接出发去酒店。&lt;br&gt;
晚上大吃一顿然后看看防爆零事项什么的。&lt;br&gt;
总体来说准备很充分，剩下的看老天爷了。&lt;/p&gt;
&lt;h3 id=&#34;day-1-night&#34;&gt;Day -1 night：&lt;/h3&gt;
&lt;p&gt;杭州真的好热，晚上有睡没睡的。&lt;/p&gt;
&lt;h3 id=&#34;day-1-morning&#34;&gt;Day 1 morning：&lt;/h3&gt;
&lt;p&gt;在酒店大堂吃了顿早餐就出发了。&lt;br&gt;
在门口遇见一堆大佬（wjz ghj yjy sk）&lt;br&gt;
进场时绕了好久，在考场外等了好久。&lt;/p&gt;
&lt;h3 id=&#34;day-1-csp-j-2021&#34;&gt;Day 1 CSP-J-2021：&lt;/h3&gt;
&lt;p&gt;今年出题人是真的良心。&lt;br&gt;
四道题三道模拟一道暴力。（bushi）&lt;br&gt;
T1就是一道数学题，模几个样例就想到做法了。&lt;br&gt;
然后我先做了T3，根据大样例找了好久的错。&lt;br&gt;
这时比赛已经过半了（T3 98行代码自愧不如）&lt;br&gt;
T2读了好久的题，草稿纸都快写满了。&lt;br&gt;
突然发现好水然后测了大样例就去做T4了。&lt;br&gt;
T4链表写炸，最后用了个暴力。&lt;br&gt;
一开始直接用肉眼看大样例答案，后来想到可以用cmd的fc，但又不会改目录，就写了一个check来判断。&lt;/p&gt;
&lt;h3 id=&#34;day-1-noon&#34;&gt;Day 1 noon：&lt;/h3&gt;
&lt;p&gt;比完后在附近吃了饭，然后就退房返城。&lt;/p&gt;
&lt;h3 id=&#34;day-n&#34;&gt;Day n:&lt;/h3&gt;
&lt;p&gt;洛谷自测300+&lt;br&gt;
J组1=，满足了&lt;/p&gt;
&lt;h2 id=&#34;part-44csp2021-j-结束&#34;&gt;Part 4.4：CSP2021-J 结束&lt;/h2&gt;
&lt;p&gt;现在看到当时的我，又有一番别的感觉。&lt;br&gt;
是对自己过去的欣慰呢还是因现在的自己没有完成过去的心愿而愧疚呢...&lt;/p&gt;
&lt;p&gt;对 不 住 了，过 去 的 我。&lt;/p&gt;
&lt;p&gt;因为：&lt;/p&gt;
&lt;h1 id=&#34;part-5长存不灭的过去逐渐消逝的未来&#34;&gt;Part 5：长存不灭的过去，逐渐消逝的未来&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;并不是OI变得更简单了，而是我，变得更坚强了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又是和往年一样努力的一年。&lt;/p&gt;
&lt;h2 id=&#34;part-51csp2022-s&#34;&gt;Part 5.1：CSP2022-S&lt;/h2&gt;
&lt;p&gt;目标：S1=。&lt;br&gt;
结果：S2=。&lt;br&gt;
明明是自己会的算法，在考场上却写不出来。&lt;br&gt;
绝望，还是绝望。&lt;br&gt;
被后辈超越，被先辈薄纱。&lt;br&gt;
第一次怀疑自己是不是走上了一条错误的路。&lt;/p&gt;
&lt;h2 id=&#34;part-52afo&#34;&gt;Part 5.2：AFO?&lt;/h2&gt;
&lt;p&gt;暂时放下了OI，补文化课去了。&lt;br&gt;
刚开始有些煎熬，却逐渐被中考的压力压得直不起身。&lt;br&gt;
可就是这暂时的放弃，让我的对OI的爱，渐渐变为虚无。&lt;/p&gt;
&lt;h1 id=&#34;part-6我回来了&#34;&gt;Part 6：我回来了&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;机会，往往是给有准备的人的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考上西交大少年班，免除中高考，来到了南开中学。&lt;br&gt;
天津，竞赛弱省，我再一次看到了重回OI的希望。&lt;br&gt;
但愿这希望，不会成为绝望...&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yydcc-blog.github.io//post-images/1697947129127.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;part-7纵使日薄西山&#34;&gt;Part 7：纵使日薄西山&lt;/h1&gt;
&lt;p&gt;我意识到，CSP2023，可能，是我的最后一场的，CCF的比赛了吧...&lt;br&gt;
这次，一定要，好好努力了，对吧？&lt;br&gt;
国庆+中午+晚自习，不停的刷题。&lt;br&gt;
只为能给自己一个好的交代。&lt;br&gt;
但是：&lt;/p&gt;
&lt;h1 id=&#34;part-8即便看不到未来&#34;&gt;Part 8：即便看不到未来&lt;/h1&gt;
&lt;p&gt;读完题目后，我没有因题目的难度感到惊讶。&lt;br&gt;
而是，最后支撑着我的那一点信念，彻底破碎。&lt;/p&gt;
&lt;p&gt;我没能遵守...&lt;/p&gt;
&lt;p&gt;约...约定&lt;/p&gt;
&lt;p&gt;可我已经...非常...非常努力了吧...&lt;/p&gt;
&lt;h1 id=&#34;part-9此时此刻的光辉&#34;&gt;Part 9：此时此刻的光辉&lt;/h1&gt;
&lt;p&gt;没想到是以这种方式结束。&lt;/p&gt;
&lt;p&gt;准考证号，写错了。&lt;/p&gt;
&lt;p&gt;哈...呵呵呵...&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://yydcc-blog.github.io//post-images/1697948514759.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;part-10盼君勿忘&#34;&gt;Part 10：盼君勿忘&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;至我最爱的OI&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;究竟要怎样&lt;/p&gt;
&lt;p&gt;才能将这份爱意铭刻在OI上？&lt;/p&gt;
&lt;p&gt;所学习到的&lt;/p&gt;
&lt;p&gt;尽是陌生的算法&lt;/p&gt;
&lt;p&gt;也请教我如何遗忘&lt;/p&gt;
&lt;p&gt;并非仅用语言而已&lt;/p&gt;
&lt;p&gt;还有那颤抖的手指的温度&lt;/p&gt;
&lt;p&gt;那又是谁的希望？&lt;/p&gt;
&lt;p&gt;自我心间满溢而出的心愿点滴&lt;/p&gt;
&lt;p&gt;就算几度消散隐没&lt;/p&gt;
&lt;p&gt;仍旧会不断地涌现&lt;/p&gt;
&lt;p&gt;没有答案的残酷未来&lt;/p&gt;
&lt;p&gt;将要到来的是第几个暴零呢&lt;/p&gt;
&lt;p&gt;若是身处陌生机房&lt;/p&gt;
&lt;p&gt;便想要被人呼唤我的名字&lt;/p&gt;
&lt;p&gt;因为胸口传来阵阵疼痛&lt;/p&gt;
&lt;p&gt;好似要撕心裂肺&lt;/p&gt;
&lt;p&gt;究竟要怎样&lt;/p&gt;
&lt;p&gt;才能将这份爱意铭刻在OI上？&lt;/p&gt;
&lt;p&gt;在我终有一天&lt;/p&gt;
&lt;p&gt;Away From OI之前&lt;/p&gt;
&lt;p&gt;心怀强烈的思念&lt;/p&gt;
&lt;p&gt;想要去守护此时此刻的理由&lt;/p&gt;
&lt;p&gt;不过是我想要更长久地守望着你&lt;/p&gt;
&lt;p&gt;我不需要什么恰到好处的AK&lt;/p&gt;
&lt;p&gt;甜美谎言所掩盖的伤痛&lt;/p&gt;
&lt;p&gt;若是能够并肩承担&lt;/p&gt;
&lt;p&gt;嘴边咽下的叹息也有了意义&lt;/p&gt;
&lt;p&gt;而后化作一场幻梦&lt;/p&gt;
&lt;p&gt;想要传达给你的誓言的点滴&lt;/p&gt;
&lt;p&gt;无法实现这一点&lt;/p&gt;
&lt;p&gt;虽已有所察觉&lt;/p&gt;
&lt;p&gt;但是啊我仍将献上祈祷&lt;/p&gt;
&lt;p&gt;即使是无法永恒的存在&lt;/p&gt;
&lt;p&gt;也想在命途多舛中&lt;/p&gt;
&lt;p&gt;寻求那真切的光芒&lt;/p&gt;
&lt;p&gt;想更多地和OI在一起&lt;/p&gt;
&lt;p&gt;即便世界毁灭&lt;/p&gt;
&lt;p&gt;不论何时&lt;/p&gt;
&lt;p&gt;爱在心上都是情不自已&lt;/p&gt;
&lt;p&gt;我一刻不停&lt;/p&gt;
&lt;p&gt;是在找寻着什么呢？&lt;/p&gt;
&lt;p&gt;虽然而今已是&lt;/p&gt;
&lt;p&gt;面临那无尽黑暗的时刻&lt;/p&gt;
&lt;p&gt;但在那之前就陪在你身旁吧&lt;/p&gt;
&lt;p&gt;将目光定格你身上&lt;/p&gt;
&lt;p&gt;如果二字刚说出口&lt;/p&gt;
&lt;p&gt;声音便伴在风中渐行渐弱&lt;/p&gt;
&lt;p&gt;好想向你倾诉我的所有&lt;/p&gt;
&lt;p&gt;好想默默将你拥入怀抱&lt;/p&gt;
&lt;p&gt;但是光阴流转所呈现的&lt;/p&gt;
&lt;p&gt;却是擦身而过渐行渐远的自己&lt;/p&gt;
&lt;p&gt;究竟要怎样&lt;/p&gt;
&lt;p&gt;才能将这爱铭刻OI上？&lt;/p&gt;
&lt;p&gt;不论何时&lt;/p&gt;
&lt;p&gt;爱在心上都是情不自已&lt;/p&gt;
&lt;p&gt;我一刻不停&lt;/p&gt;
&lt;p&gt;是在找寻着什么呢？&lt;/p&gt;
&lt;p&gt;心怀强烈的思念&lt;/p&gt;
&lt;p&gt;想要去守护此时此刻的理由&lt;/p&gt;
&lt;p&gt;不过是我想要更长久地守望着你&lt;/p&gt;
&lt;p&gt;Away From OI之前&lt;/p&gt;
&lt;h1 id=&#34;part-11世上最幸福的oier&#34;&gt;Part 11：世上最幸福的OIer&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;其实这个Part就是后记啦awa&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;10月21号高考完就认清了事实，将自己这7年发自内心的感慨写了下来。&lt;/p&gt;
&lt;p&gt;之后若我想起其他事也会补充上来。&lt;/p&gt;
&lt;p&gt;是时候该退役了。&lt;/p&gt;
&lt;p&gt;非常感谢这一路以来陪伴我的父母、同学、老师、学校、各大OJ。&lt;/p&gt;
&lt;p&gt;也感谢看完全文的读者们（是不是有点水awa）。&lt;/p&gt;
&lt;p&gt;我已经，没有任何遗憾了。&lt;/p&gt;
&lt;p&gt;我还是深深爱着OI的哦awa&lt;/p&gt;
&lt;p&gt;但是，是时候说再见了。&lt;/p&gt;
&lt;p&gt;希望有朝一日，我能，再次踏上这个舞台。&lt;/p&gt;
&lt;h1 id=&#34;away-from-oi-at-20231021&#34;&gt;Away From OI at 2023/10/21&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://yydcc-blog.github.io//post-images/1697948900781.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">【2023AFO纪念】AFO了在做什么？有没有空？可以重新再来吗？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/na-xie-ni-bi-xu-hui-de-mo-ban-ii/"" data-c="
          &lt;p&gt;最短路篇&lt;/p&gt;
&lt;h1 id=&#34;floyd-spfa-and-dijkstra&#34;&gt;Floyd、SPFA and Dijkstra&lt;/h1&gt;
&lt;h2 id=&#34;松弛操作&#34;&gt;松弛操作&lt;/h2&gt;
&lt;p&gt;最短路核心操作，可以理解成三角形的三边关系的翻版。（两边之和大于第三边-&amp;gt;取两边之和和第三边的最小值）&lt;/p&gt;
&lt;h2 id=&#34;floyd-多源最短路&#34;&gt;Floyd 多源最短路&lt;/h2&gt;
&lt;p&gt;时间复杂度：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n^3)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用邻接矩阵，枚举中转点和两个点，更新这两个点之间的最短距离：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;min(dis_{x-y},dis_{x-k}+dis_{k-y})&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.25833100000000003em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3361079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.208331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3361079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码过于简单不放了awa&lt;/p&gt;
&lt;h2 id=&#34;spfa-它死了考场慎用&#34;&gt;SPFA 它死了（考场慎用）&lt;/h2&gt;
&lt;p&gt;时间复杂度：最差&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nm)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;会被卡死。（有谷民甚至卡到200s）&lt;/p&gt;
&lt;p&gt;真正用SPFA来解决最短路的很少，主要来处理有负权，判断正负环，差分约束。&lt;/p&gt;
&lt;p&gt;使用桟或队列实现。（在有负环的情况下，栈比队列更快，但是如果没有负环的一般情况下，队列更快。）&lt;/p&gt;
&lt;h3 id=&#34;桟实现spfa&#34;&gt;桟实现SPFA&lt;/h3&gt;
&lt;p&gt;这和dfs有什么区别awa&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void spfa(int u){
	vis[u]=1;
	for(int e=head[u];e;e=nxt[e]){
		int v=to[e];
		if(dis[v]&amp;gt;dis[u]+sum[e]){
			dis[v]=dis[u]+sum[e];
			if(!vis[v])spfa(v);
		}
	}
	vis[u]=0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;队列实现spfa&#34;&gt;队列实现SPFA&lt;/h3&gt;
&lt;p&gt;先把源点进队，然后用源点扩展更新，能迭代的都进队……&lt;br&gt;
就是用队列里的点去迭代其他点，被迭代的点再次进队。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SPFA(){
	for(int i=1;i&amp;lt;=m;i++)
		dis[i]=2147483647;
	dis[t]=0;
	Q.push(t);
	vis[t]=1;
	while(!Q.empty()){
		int u=Q.front();
		Q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=e[i].nex){
			int v=e[i].to;
			if(dis[v]&amp;gt;dis[u]+e[i].len){
				dis[v]=dis[u]+e[i].len;
				if(!vis[v]){
					Q.push(v);
					vis[v]=1;
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;spfa拓展&#34;&gt;SPFA拓展&lt;/h3&gt;
&lt;h4 id=&#34;判断负环&#34;&gt;判断负环&lt;/h4&gt;
&lt;p&gt;朴素做法：直接桟实现SPFA判断是否有重复松弛即可。&lt;/p&gt;
&lt;p&gt;优化想法：&lt;/p&gt;
&lt;p&gt;我们只需要找到权值和为负的回路，那不妨使距离数组 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dis&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 初始化为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;br&gt;
这样处理后，第一次拓展只会拓展到与起点相连边权为负的边。&lt;br&gt;
那么我们就分别枚举所有的点作为起点，如果已经找到一个负环就不再继续枚举。&lt;br&gt;
根据SPFA，我们找到的负环一定包含当前枚举的这个点。&lt;/p&gt;
&lt;h4 id=&#34;差分约束&#34;&gt;差分约束&lt;/h4&gt;
&lt;p&gt;不讲awa&lt;/p&gt;
&lt;h2 id=&#34;dijkstra-不会被卡但不能处理负权值&#34;&gt;Dijkstra 不会被卡，但不能处理负权值。&lt;/h2&gt;
&lt;p&gt;使用 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dis&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示源点到每个点的最短距离。（初始为无限大，自己到自己为0）&lt;/p&gt;
&lt;p&gt;每次找一个 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dis&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 值最小的没用过的点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,遍历 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的所有出边进行松弛操作即可。&lt;/p&gt;
&lt;p&gt;因此可以用堆优化到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n log n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void dij(int x){
	for(int i=1;i&amp;lt;=n;i++)
		dis[i]=(i==x)?0:1e9;
	priority_queue&amp;lt;pair&amp;lt;int,int&amp;gt; &amp;gt; q;
	q.push(make_pair(0,x));
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int e=head[u];e;e=nxt[e]){
			int v=to[e];
			if(dis[v]&amp;gt;dis[u]+sum[e]){
				dis[v]=dis[u]+sum[e];
				q.push(make_pair(-dis[v],v));
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
">那些你必须会的模板II</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/na-xie-ni-bi-xu-hui-de-mo-ban-i/"" data-c="
          &lt;h1 id=&#34;并查集-快速幂-and-线性筛素数&#34;&gt;并查集、快速幂 and 线性筛素数。&lt;/h1&gt;
&lt;h2 id=&#34;并查集&#34;&gt;并查集&lt;/h2&gt;
&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;如题，现在有一个并查集，你需要完成合并和查询操作。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也就是说我们要维护集合的操作，那该怎么做呢？&lt;/p&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;我们用 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;fa_x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的从属关系。（一开始 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;fa_x=x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，也就是自己一个元素一个集合）&lt;/p&gt;
&lt;p&gt;将 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 所属的集合和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 所属的集合合并时，即让 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;fa_y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15139200000000003em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 变为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 所属集合的最顶部的 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;fa_{top}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.28055599999999997em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。（也可以理解成连上去）&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Find(int a){
	if(a==fa[a])return a;
	return Find(fa[a]);
}

fa[y]=Find(x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;路径压缩&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Find(a)&lt;/code&gt;的过程中将路径上的所有点直接连到最高点。（可以理解成从一条链压缩成菊花图）&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Find(int a){
	if(a==fa[a])return a;
	return fa[a]=Find(fa[a]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;快速幂&#34;&gt;快速幂&lt;/h2&gt;
&lt;h3 id=&#34;描述-2&#34;&gt;描述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;快速求幂awa&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;实现-2&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;就是指数除2底数平方。&lt;/p&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int fpower(int x,int y,int mod){
	int ans=1;
	while(y){
		if(y%2)ans=ans*x%mod;//奇数单独处理
		x=x*x%mod;
		y&amp;gt;&amp;gt;=1;
	}
	return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;线性筛素数&#34;&gt;线性筛素数&lt;/h2&gt;
&lt;h3 id=&#34;描述-3&#34;&gt;描述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;如题，给定一个范围 n，有 q 个询问，每次输出第 k 小的素数。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最朴素的筛法：埃氏筛。&lt;/p&gt;
&lt;p&gt;每次将素数的倍数筛去，因为会有很多被重复筛的数，最好也只能做到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n log log n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;10^8&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 这个阶级会超时。&lt;/p&gt;
&lt;p&gt;所以我们考虑下面这种做法。&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;欧拉筛&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;考虑每个合数只被筛一次。&lt;/p&gt;
&lt;p&gt;原则：这个合数只会被它的最大非自身因数（对应最小质因数）筛。&lt;/p&gt;
&lt;p&gt;每次循环已经筛过的质数去乘当前的数，当这个数为质数的倍数时停止。&lt;/p&gt;
&lt;p&gt;此时这个质数为它的最小质因数，符合原则。&lt;/p&gt;
&lt;p&gt;但下一个质数不符合，这个合数可以拆分出为比这个质数更小的质数（上一个）。&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for(int i=2;i&amp;lt;=n;i++){
	if(!flag[i])prime[++cnt]=i;
	for(int j=1;j&amp;lt;=cnt&amp;amp;&amp;amp;i*prime[j]&amp;lt;=n;j++){
		flag[i*prime[j]]=1;
		if(!i%prime[j])break;
	}
}
&lt;/code&gt;&lt;/pre&gt;
">那些你必须会的模板I</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/bu-dan-diao-de-dan-diao-dui-lie/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;单调队列的用处非常广泛！&lt;/p&gt;
&lt;p&gt;今天也要加油哦ヾ(◍°∇°◍)ﾉﾞ&lt;/p&gt;
&lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;
&lt;p&gt;维护一个队列，使其保持降序或升序状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;queue&lt;/code&gt;：队列数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt;：队列头下标。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tail&lt;/code&gt;：队列尾下标。&lt;/p&gt;
&lt;h1 id=&#34;例题&#34;&gt;例题&lt;/h1&gt;
&lt;h2 id=&#34;洛谷p1886-滑动窗口-模板单调队列&#34;&gt;洛谷P1886 滑动窗口 /【模板】单调队列&lt;/h2&gt;
&lt;p&gt;单调队列模板题，维护两个队列，一个升序一个降序。&lt;/p&gt;
&lt;p&gt;每次先将不在范围内的元素出队，即 &lt;code&gt;head++&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再维护单调性，将破坏单调性的去除，即 &lt;code&gt;tail--&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后入队：&lt;code&gt;queue[++tail]=i&lt;/code&gt;。（入队的要为原数组下标）&lt;/p&gt;
&lt;p&gt;最值即为队头：&lt;code&gt;queue[head]&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;洛谷p1714-切蛋糕&#34;&gt;洛谷P1714 切蛋糕&lt;/h2&gt;
&lt;p&gt;暴力做法：前缀和，再枚举起点终点求最值即可。&lt;/p&gt;
&lt;p&gt;但这显然会超时。&lt;/p&gt;
&lt;p&gt;对于每一个前缀和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sum_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，以这个为结尾的最大值就为它减去前面区间的最小值，即 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;区&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;长&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;度&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;sum_i - min(sum_{j}) (i-[区间长度]-1&amp;lt;j&amp;lt;i)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;区&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;长&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;度&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68354em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以用一个单调队列维护最小值即可。&lt;/p&gt;
&lt;h2 id=&#34;洛谷p2698-usaco12marflowerpot-s&#34;&gt;洛谷P2698 [USACO12MAR]Flowerpot S&lt;/h2&gt;
&lt;p&gt;我们用两个优先队列，一个存区间最大值，一个存区间最小值。&lt;/p&gt;
&lt;p&gt;最外层循环拉左端点（因为要里面右端点移完再动左端点）&lt;/p&gt;
&lt;p&gt;每次先用两个while循环更新队首,直到队首不在左端点左边（因为移动了左端点有一个点的值就不能用了）&lt;/p&gt;
&lt;p&gt;然后第二层循环移动右端点，直到达到右边界或满足条件（最大值-最小值 &amp;gt; d）。&lt;/p&gt;
&lt;p&gt;里面再用两个循环类似滑动窗口更新最大值队列和最小值队列（只要队中还有元素且新加入的元素比队尾大（维护最大值时为小）那么就队尾出队，不需要管队首出队（这是更新左端点做的事情））。&lt;/p&gt;
&lt;p&gt;第二层循环结束后，如果满足条件就更新 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ans&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ans&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 要初始化成一个很大的值）。&lt;/p&gt;
&lt;p&gt;一切结束后如果 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ans&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 还是初始值，就输出 “-1”，否则输出 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ans&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;用单调队列优化DP非常常见。&lt;/p&gt;
&lt;p&gt;题单就放在这里啦：&lt;a href=&#34;https://www.luogu.com.cn/training/209636#problems&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
">不单调的单调队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/xian-duan-shu-cong-ru-men-dao-tui-keng-er/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;此文章介绍的均为加法操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;前言&#34;&gt;前言：&lt;/h1&gt;
&lt;p&gt;上篇文章介绍了线段树的基础操作。&lt;/p&gt;
&lt;p&gt;其中区间修改用递归的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高。&lt;/p&gt;
&lt;p&gt;所以这篇文章引入一个新概念：懒惰标记。&lt;/p&gt;
&lt;p&gt;今天也要加油哦！😙&lt;/p&gt;
&lt;h1 id=&#34;part-3懒惰标记lazy_tag&#34;&gt;Part 3：懒惰标记（lazy_tag）&lt;/h1&gt;
&lt;h2 id=&#34;part-31概念引入&#34;&gt;Part 3.1：概念引入&lt;/h2&gt;
&lt;p&gt;使用懒惰标记，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个标记，将来要用到它的子区间的时候，再向下传递。&lt;/p&gt;
&lt;h2 id=&#34;part-32分析&#34;&gt;Part 3.2：分析&lt;/h2&gt;
&lt;p&gt;首先定义一个标记数组：&lt;code&gt;tag[这里的下标和线段树一样]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表示这一段区间打上的标记。&lt;/p&gt;
&lt;p&gt;接下来介绍标记的几种操作。&lt;/p&gt;
&lt;h3 id=&#34;part-321-标记的传递&#34;&gt;Part 3.2.1: 标记的传递&lt;/h3&gt;
&lt;p&gt;对于区间 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;r&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，懒惰标记为 &lt;code&gt;tag[p]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;分别传递到左右区间的标记：&lt;code&gt;tag[p&amp;lt;&amp;lt;1]+=tag[p];tag[p&amp;lt;&amp;lt;1|1]+=tag[p];&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再将左右区间的值改变：&lt;code&gt;ans[p&amp;lt;&amp;lt;1]+=tag[p]*(mid-l+1);ans[p&amp;lt;&amp;lt;1|1]+=tag[p]*(r-mid);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后删除原来的标记：&lt;code&gt;tag[p]=0;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;part-321结合&#34;&gt;Part 3.2.1：结合&lt;/h3&gt;
&lt;p&gt;在区间求和和区间修改的每次分治前下放标记。&lt;/p&gt;
&lt;p&gt;区间修改时要再加上标记即可。&lt;/p&gt;
&lt;h2 id=&#34;part-33代码总结&#34;&gt;Part 3.3：代码总结&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline ll ls(ll x){
    return x&amp;lt;&amp;lt;1;
}
inline ll rs(ll x){
    return x&amp;lt;&amp;lt;1|1;
}
inline void push_up(ll p){
    ans[p]=ans[ls(p)]+ans[rs(p)];
}
void build(ll p,ll l,ll r){
    tag[p]=0;
    if(l==r){ans[p]=a[l];return ;}
    ll mid=(l+r)&amp;gt;&amp;gt;1;
    build(ls(p),l,mid);
    build(rs(p),mid+1,r);
    push_up(p);
} 
inline void f(ll p,ll l,ll r,ll k){
    tag[p]=tag[p]+k;
    ans[p]=ans[p]+k*(r-l+1);
}
inline void push_down(ll p,ll l,ll r){
    ll mid=(l+r)&amp;gt;&amp;gt;1;
    f(ls(p),l,mid,tag[p]);
    f(rs(p),mid+1,r,tag[p]);
    tag[p]=0;
}
inline void update(ll nl,ll nr,ll l,ll r,ll p,ll k){
    if(nl&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=nr){
        ans[p]+=k*(r-l+1);
        tag[p]+=k;
        return ;
    }
    push_down(p,l,r);
    ll mid=(l+r)&amp;gt;&amp;gt;1;
    if(nl&amp;lt;=mid)update(nl,nr,l,mid,ls(p),k);
    if(nr&amp;gt;mid) update(nl,nr,mid+1,r,rs(p),k);
    push_up(p);
}
ll query(ll q_x,ll q_y,ll l,ll r,ll p){
    ll res=0;
    if(q_x&amp;lt;=l&amp;amp;&amp;amp;r&amp;lt;=q_y)return ans[p];
    ll mid=(l+r)&amp;gt;&amp;gt;1;
    push_down(p,l,r);
    if(q_x&amp;lt;=mid)res+=query(q_x,q_y,l,mid,ls(p));
    if(q_y&amp;gt;mid) res+=query(q_x,q_y,mid+1,r,rs(p));
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;part-4线段树进阶&#34;&gt;Part 4：线段树进阶&lt;/h1&gt;
&lt;p&gt;留到下次再讲吧😄&lt;/p&gt;
">线段树，从入门倒退坑-贰</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/qian-tan-ida/"" data-c="
          &lt;p&gt;为什么想到写这个了呢，因为实在是太好用了。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;文章其实是转载来的&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&#34;ida算法迭代加深的评估函数&#34;&gt;IDA*算法：迭代加深的+评估函数&lt;/h1&gt;
&lt;p&gt;A&lt;em&gt;算法的本质时带评估函数的优先队列BFS，其最关键的部分在于评估函数的选取。那么可以考虑在DFS中也采用相同的优化。IDA&lt;/em&gt;就是这部一种算法，IDA*=迭代加深DFS+评估函数（迭代加深：限定深度搜索，如果当前深度找不到，再增大深度限制）。&lt;/p&gt;
&lt;p&gt;由于迭代加深DFS和优先队列BFS的特性不同，此时评估函数评估的内容应该是当前状态到目标状态的步数，并且估计数不超过实际数，那么判断是否过深度限制时，可以用当前步数+估计步数，如果该值超过深度限制，则不需要继续搜索，可以立即回溯。&lt;/p&gt;
&lt;p&gt;IDA*算法实现简单，效率高，通过不搜索当前步数+估计步数超过深度限制的状态，减少了很多搜索量，是一种良好的优化方式。&lt;/p&gt;
&lt;h1 id=&#34;例题&#34;&gt;例题&lt;/h1&gt;
&lt;h2 id=&#34;排书poj3460acwing180&#34;&gt;排书(POJ3460/AcWing180)&lt;/h2&gt;
&lt;h3 id=&#34;题目大意&#34;&gt;题目大意&lt;/h3&gt;
&lt;p&gt;N本书，编号&lt;code&gt;1~n&lt;/code&gt;，给出初始排列顺序，每次抽取连续的一段书插到另一个位置，求让书按1~n排列最少的操作数。（n&amp;lt;=15，若干组数据）超过5次搜索，直接输出5 or more。&lt;/p&gt;
&lt;h3 id=&#34;解析&#34;&gt;解析&lt;/h3&gt;
&lt;p&gt;采用IDA*。目标状态为书本按顺序排列，因此第i本书后应该是第i+1本书，即i+1是i的正确后继。对任意状态，若整个排列中书的错误后继数量为t，那么一次操作最多改变3本书的后继，那么即便是理想状态要进行的操作也至少为t//3（向上取整）。可以用t//3（向上取整）作为评估函数。&lt;br&gt;
采用迭代加深，从1~4依次限制深度，从起始状态出发DFS，枚举各种抽书排书的可能；进入一个状态后，如果当前操作数+评估函数超过深度限制，就直接回溯。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;
&lt;p&gt;可以看到，IDA&lt;em&gt;的实现相对比较简单，只需要确定对应的评估函数，就可以在原本的迭代加深DFS代码上修改判断依据即可，在代码量上不会增加多少难度。它的关键在于如何确定一个合适的评估函数，既要不超过实际剩余步数，又要尽可能贴近实际剩余步数，展示一定剩余步数的趋势（和A&lt;/em&gt;一样）&lt;/p&gt;
">浅谈IDA*</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/xian-duan-shu-cong-ru-men-dao-tui-keng/"" data-c="
          &lt;h1 id=&#34;part0前言&#34;&gt;Part0：前言&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你在考提高组前一天还在问这个问题，那么你会与一等奖失之交臂；如果你还在冲击普及组一等奖，那么这篇博客会浪费你人生中宝贵的5~20分钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;part1概念引入建树以区间求和为例&#34;&gt;Part1：概念引入+建树（以区间求和为例）&lt;/h1&gt;
&lt;h2 id=&#34;part11概念引入&#34;&gt;Part1.1：概念引入&lt;/h2&gt;
&lt;p&gt;线段树，顾名思义，用线性的方式保存一颗二叉树。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;有一串数&lt;code&gt;1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么构造出的线段树就为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;                     1(123456789)
          2(1234)                    3(56789)
   4(12)       5(34)          6(56)           7(789)
8(1) 9(2)     10(3) 11(4)   12(5) 13(6)      14(7) 15(89)
                                                  16(8) 17(9)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中括号内的数表示当前这个下标维护的范围。&lt;/p&gt;
&lt;h2 id=&#34;part12建树&#34;&gt;Part1.2：建树&lt;/h2&gt;
&lt;p&gt;用递归的方法建树。&lt;code&gt;void build(int p,int l,int r)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;p&lt;/code&gt;表示下标，&lt;code&gt;l r&lt;/code&gt;表示区间的范围。&lt;/p&gt;
&lt;p&gt;如果 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;l=r&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，说明此时为叶子节点，直接赋值。&lt;/p&gt;
&lt;p&gt;否则将区间分为两个，分别建树，下标为&lt;code&gt;*2&lt;/code&gt;和&lt;code&gt;*2+1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后维护各节点的信息，为它的两个子节点的和。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void build(int p,int l,int r){
    if(l==r){tree[p]=a[l];return ;}
    int mid=(l+r)&amp;gt;&amp;gt;1;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    push_up(p);//维护信息
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;part2区间查询修改以区间求和为例&#34;&gt;Part2：区间查询+修改（以区间求和为例）&lt;/h1&gt;
&lt;h2 id=&#34;part21区间查询&#34;&gt;Part2.1：区间查询&lt;/h2&gt;
&lt;p&gt;递归法查询。&lt;/p&gt;
&lt;p&gt;如果查询区间在当前区间中，返回线段树数组中当前下标所对应的值。&lt;/p&gt;
&lt;p&gt;不然将查询分成两部分。&lt;/p&gt;
&lt;p&gt;如果有一部分在左区间，就将左区间的查询结果加上。右区间同理。&lt;/p&gt;
&lt;p&gt;最终返回左区间和右区间的查询结果之和即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int search(int i,int l,int r){
    if(tree[i].l&amp;gt;=l &amp;amp;&amp;amp; tree[i].r&amp;lt;=r)//如果这个区间被完全包括在目标区间里面，直接返回这个区间的值
        return tree[i].sum;
    if(tree[i].r&amp;lt;l || tree[i].l&amp;gt;r)  return 0;//如果这个区间和目标区间毫不相干，返回0
    int s=0;
    if(tree[i*2].r&amp;gt;=l)  s+=search(i*2,l,r);//如果这个区间的左儿子和目标区间又交集，那么搜索左儿子
    if(tree[i*2+1].l&amp;lt;=r)  s+=search(i*2+1,l,r);//如果这个区间的右儿子和目标区间又交集，那么搜索右儿子
    return s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;part22区间修改&#34;&gt;Part2.2：区间修改&lt;/h2&gt;
&lt;p&gt;和区间查询类似。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void add(int i,int dis,int k){
    if(tree[i].l==tree[i].r){//如果是叶子节点，那么说明找到了
        tree[i].sum+=k;
        return ;
    }
    if(dis&amp;lt;=tree[i*2].r)  add(i*2,dis,k);//在哪往哪跑
    else  add(i*2+1,dis,k);
    tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;//返回更新
    return ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;part-3标记操作到下一篇讲&#34;&gt;Part 3：标记操作到下一篇讲&lt;/h1&gt;
">线段树，从入门到退坑</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/windowsh-zhong-dao-di-you-shi-me/"" data-c="
          &lt;h1 id=&#34;第一个&#34;&gt;第一个：&lt;/h1&gt;
&lt;p&gt;FindWindow根据窗口类名或窗口标题名来获得窗口的句柄，该函数返回窗口的句柄， 这个函数的定义是这样的 HWND WINAPI FindWindow(LPCSTR lpClassName,LPCSTR lpWindowName);&lt;/p&gt;
&lt;p&gt;第一个参数填窗口的类名，第二个填窗口的标题名，其实是不需要同时填两个参数的，也就是说，你只要知道窗口的类名或窗口的标题就可以了，没有的那个就用NULL代替。&lt;/p&gt;
&lt;p&gt;比如现在有一个窗口名为&amp;quot;无标题.txt - 记事本&amp;quot;的记事本程序。那么我就可以用上面的函数获得这个窗口的句柄，那获得了这个窗口的句柄我可以干什么呢？作用可大了，因为很多操作窗口的函数，都需要窗口句柄作参数，如移动、改变窗口大小的MoveWindow函数，在这里举个例子，大家就更能体会到这个FindWindow的用法、用处。&lt;/p&gt;
&lt;p&gt;FindWindow例子：已知一个窗口名称，写一个程序关闭该窗口，假设当前电脑正有一个窗口名为&amp;quot;无标题.txt - 记事本&amp;quot;的记事本程序运行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;//API函数的头文件
int main() { 
    HWND wnd;//定义一个窗口句柄变量，用以存储找到的窗口句柄
    wnd=FindWindow(NULL,&amp;quot;无标题.txt - 记事本&amp;quot;);//获得窗口名为&amp;quot;无标题.txt - 记事本&amp;quot;的窗口句柄
    SendMessage(wnd,WM_CLOSE,0,0);//调用SendMessage函数，发送一个WM_CLOSE（关闭）消息给wnd窗口句柄。
    return 0; 
} //如果要根据窗口类名来获得窗口句柄话，只要给函数的第一个参数填类名，第二个参数窗口名填NULL，即可，用Spy++可查看窗口类名。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第二个&#34;&gt;第二个：&lt;/h1&gt;
&lt;p&gt;SendMessage根据窗口句柄发送一个消息给窗口&lt;/p&gt;
&lt;p&gt;函数定义：LRESULT SendMessage（HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam）；&lt;/p&gt;
&lt;p&gt;第一个参数是窗口句柄，第二参数个是消息类型，下面的消息表列举了所有消息，第三，四个参数是消息附带信息，解释依赖于消息类型，比如一个字符消息（WM_CHAR),那么第三个参数就储存有一个字符的ASCII码。&lt;/p&gt;
&lt;p&gt;消息机制大家都应该知道吧，Windows是基于消息的系统，鼠标移动键盘按键都会产生消息。 接下来举一个例子，发送一个WM_CHAR消息给窗口，也就是模仿键盘按键，接收消息的窗口依旧以&amp;quot;无标题.txt - 记事本&amp;quot;为例： SendMessage例子：模仿键盘按键&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;
int main() { 
    HWND wnd; 
    wnd=FindWindow(NULL,&amp;quot;无标题.txt - 记事本&amp;quot;);
    while(1) { 
        SendMessage(wnd,WM_CHAR,WPARAM(&#39;a&#39;),0); 
        Sleep(300); 
    }
    return 0; 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;呵呵上面的例子是不是没用，这是为什么呢，哪里出错了吗？错倒是没有错，只是窗口句柄有问题，消息发送给了主窗口。接收消息的窗口不对。记事本窗口界面有些有什么东西呢？菜单，编辑框，状态栏等控件，控件也是窗口，既然是窗口，那当然它们也有窗口句柄，而在记事本里是在哪里打字的？编辑框控件里打字的嘛！所以消息应该发送编辑框控件，那如何获得记事本里编辑框控件的窗口句柄呢？用FindWindow吗？不知道编辑框窗口标题名，类名也不知道，当然也有其它方法获取编辑框窗口标题名和窗口类名，如Spy++。关于如何获得编辑框句柄，将在以后的函数中会有介绍，这里我们就用WindowFromPoint这个函数来获取，这个函数获取窗口句柄的方法比较笨，（相对于我这个例子来说），这个函数是根据什么来获取窗口句柄的呢？根据屏幕坐标点，如屏幕坐标点20，20，当前是哪个窗口占有，就返回哪个窗口的句柄。有了这个函数，我们还需要一个函数GetCursorPos获取鼠标当前位置（针对于屏幕）； 可行的例子：模仿键盘按键：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;
int main() { 
    POINT curpos;//一个可储存坐标点的结构体变量，x横坐标，y,纵坐标，如curpos.x curpos.y
    while(1) { 
        GetCursorPos(&amp;amp;curpos);//获取当前鼠标的位置，位置将储存在curpos里。
        HWND hWnd = WindowFromPoint(curpos);//根据curpos所指的坐标点获取窗口句柄
        SendMessage(hWnd,WM_CHAR,WPARAM(&#39;g&#39;),0);//发送一个字符（按键）消息g给当前鼠标所指向的窗口句柄
        Sleep(300);//睡眠三百毫秒，相当于等待三分之一秒} } 这个程序一运行后，只要把鼠标指向要输入字符的窗口句柄，那么就相当于键盘每三分之一秒按了一个g键，试试吧！ 如果这样觉得模仿键盘按键太麻烦的话，那么就用keybd_event这个函数，这个专门用于模仿键盘按键的，关于怎么用，自己百度一搜，就知道了。既然SendMessage能模仿键盘按键的话，那也能模仿鼠标左击，右击。而此时SendMessage函数第三，四个参数的解释就是储存有鼠标左击，右击时的位置。如模仿鼠标右击，想一想，一次鼠标右击有哪几步，分别是鼠标右键按下，鼠标右键松开，如果你按下鼠标右键不松开，那它是不是鼠标右击，不是的，直到你松开鼠标右键，才能算是一次完整的鼠标右击.鼠标右键按下的消息类型是“WM_RBUTTONDOWN”，右键松开的消息是“WM_RBUTTONUP”，那么一次完整的鼠标右击应该是： 
        SendMessage(wnd,WM_RBUTTONDOWN,0,0);//鼠标右键按下,第三，四个参数说明了鼠标按下时的位置Sleep(100);//间隔100毫秒
        SendMessage(wnd,WM_RBUTTONUP,0,0);//鼠标右键松开同样，也有一个专门模仿鼠标动作的函数，mouse_event这个函数，可以模仿鼠标的移动，单击，双击等。以后会有专门介绍。
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第三个&#34;&gt;第三个：&lt;/h1&gt;
&lt;p&gt;GetCursorPos获取鼠标当前位置（屏幕） 这个函数在SendMessage函数有介绍，这里仅举一个例子，在界面里不停的输出鼠标当前位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
int main() { 
    POINT curpos;
    while(1) { 
        GetCursorPos(&amp;amp;curpos); 
        printf(&amp;quot;x:%d,y:%d&amp;quot;,curpos.x,curpos.y); 
        Sleep(300); 
        printf(&amp;quot;\n&amp;quot;); 
    } 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第四个&#34;&gt;第四个：&lt;/h1&gt;
&lt;p&gt;WindowFromPoint根据坐标点获得对应的窗口句柄 在SendMessage有解释，这里仅举一个例子，鼠标指向哪个窗口，就关闭哪个窗口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;
int mai() { 
    Sleep(2500);//等待一会儿，用于把鼠标移到其它窗口上去，避免指向本身进程的窗口，关掉自己的窗口。
    POINT curpos;
    while(1) { 
        GetCursorPos(&amp;amp;curpos); 
        HWND wnd=WindowFromPoint(curpos); 
        SendMessage(wnd,WM_CLOSE,0,0); 
        Sleep(300); 
    }
    return 0; 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第五个&#34;&gt;第五个：&lt;/h1&gt;
&lt;p&gt;MoveWindow根据窗口句柄移动窗口，改变窗口大小 函数定义：BOOL MoveWindow( HWND hWnd, int X, int Y, intnWidth, int nHeight, BOOL bRepaint );&lt;/p&gt;
&lt;p&gt;hWnd是要改变大小的窗口的句柄，x,y相对于屏幕的坐标，窗口左上角的位置与之相对应，nWidth和nHeight是窗口新的宽高，bRepaint指定窗口是否重画。&lt;/p&gt;
&lt;p&gt;这里依旧以&amp;quot;无标题.txt - 记事本&amp;quot;为例子，改变这个窗口大小，并把窗口移到左上角去。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;
int main() { 
    HWND wnd; 
    wnd=FindWindow(NULL,&amp;quot;无标题.txt - 记事本&amp;quot;); 
    MoveWindow(wnd,0,0,220,120,NULL);
    return 0; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第六个&#34;&gt;第六个：&lt;/h1&gt;
&lt;p&gt;ShowWindow设置窗口显示状态，如隐藏，最大化，最小化 函数定义BOOL ShowWinow(HWND hWnd,int nCmdShow); SW_HIDE：隐藏窗口并激活其他窗口。第一个参数hWnd指明了窗口句柄，第二个参数指明了窗口的状态，现在给出第二个参数常用取值范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SW_MAXIMIZE：最大化指定的窗口。&lt;/li&gt;
&lt;li&gt;SW_MINIMIZE：最小化指定的窗口并且激活在Z序中的下一个顶层窗口。&lt;/li&gt;
&lt;li&gt;SW_RESTORE：激活并显示窗口。如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置。在恢复最小化窗口时，应用程序应该指定这个标志。&lt;/li&gt;
&lt;li&gt;SW_SHOW：在窗口原来的位置以原来的尺寸激活和显示窗口。&lt;/li&gt;
&lt;li&gt;ShowWindow例子：程序运行后，在桌面上隐藏一个指定的窗口，并在4秒后再将其显示&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;
int main() { 
    HWND wnd; 
    wnd=FindWindow(NULL,&amp;quot;无标题.txt - 记事本&amp;quot;); 
    ShowWindow(wnd,SW_HIDE); 
    Sleep(5000); 
    ShowWindow(wnd,SW_SHOW);
    return 0; 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第七个&#34;&gt;第七个：&lt;/h1&gt;
&lt;p&gt;SetCursorPos设置鼠标的位置、把鼠标移动到指定的位置&lt;/p&gt;
&lt;p&gt;函数定义：BOOL SetCursorPos(int x,int y);&lt;/p&gt;
&lt;p&gt;这个函数的两个参数我想大家应该知道是什么意思吧，屏幕的坐标点。 直接看例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;
int main() { 
    int sec=0;
    while(sec&amp;lt;200) { 
        SetCursorPos(rand()%1024,rand()%768);//随机设置鼠标的位置
        Sleep(20); 
        sec++; 
    }
    return 0; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第八个&#34;&gt;第八个：&lt;/h1&gt;
&lt;p&gt;CopyFile复制一个文件&lt;/p&gt;
&lt;p&gt;如何复制一个文件，比如，我要把E盘的abb.txt的文本文件复制到d盘的zhengyong.txt,则调用语句 CopyFile(&amp;quot;e:\abb.txt&amp;quot;,&amp;quot;d:\zhengyong.txt&amp;quot;,FALSE);即可。&lt;/p&gt;
&lt;p&gt;第三个参数有以下说明： 如果设为TRUE（非零），那么一旦目标文件已经存在，则函数调用会失败。否则目标文件会被覆盖掉。&lt;/p&gt;
&lt;h1 id=&#34;第九个&#34;&gt;第九个：&lt;/h1&gt;
&lt;p&gt;DeleteFile删除一个文件 如何删除一个文件，语句：DeleteFile(&amp;quot;e\abb.txt&amp;quot;);既是删除 如果目标为隐藏或只读，则无用。&lt;/p&gt;
&lt;h1 id=&#34;第十个&#34;&gt;第十个：&lt;/h1&gt;
&lt;p&gt;CreateDirectory创建一个文件夹（目录）&lt;/p&gt;
&lt;p&gt;假如E盘下什么文件也没有 CreateDirectory(&amp;quot;e:\aaa\bbb&amp;quot;,NULL);这样是错的，不能同时建两个文件，除非E盘下已经有了个aaa文件夹了。&lt;/p&gt;
&lt;p&gt;这样是对的CreateDirectory(&amp;quot;e:\aaa&amp;quot;,NULL);&lt;/p&gt;
&lt;h1 id=&#34;第十一个&#34;&gt;第十一个：&lt;/h1&gt;
&lt;p&gt;GetClientRect获得窗口大小(客户区）&lt;br&gt;
看例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
int main(int argc, char* argv[]) { 
    HWND wnd;
    while(1) { 
        wnd=FindWindow(NULL,&amp;quot;无标题.txt - 记事本&amp;quot;); 
        RECT rect;//专门用来存储窗口大小
        GetClientRect(wnd,&amp;amp;rect);//获取窗口大小
        printf(&amp;quot;%d,%d,%d,%d\n&amp;quot;,rect.left,rect.top,rect.right,rect.bottom);//输出窗口大小，试着用鼠标改变窗口大小
        Sleep(300);
     }
 }
&lt;/code&gt;&lt;/pre&gt;
">windows.h中到底有什么</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/live-huo-zhao/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;by 黑_白（永远的CC）&lt;/p&gt;
&lt;h1 id=&#34;代码行数149行&#34;&gt;代码行数：149行&lt;/h1&gt;
&lt;h1 id=&#34;更新日志&#34;&gt;更新日志&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;第一个版本1️⃣&lt;/li&gt;
&lt;li&gt;添加了不同人数🚻&lt;/li&gt;
&lt;li&gt;添加了对作弊者的惩治☠️&lt;/li&gt;
&lt;li&gt;添加了亡语👻&lt;/li&gt;
&lt;li&gt;第二个版本2️⃣&lt;/li&gt;
&lt;li&gt;避免了自杀🤡&lt;/li&gt;
&lt;li&gt;添加了技能🎌&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;判定数字机制&#34;&gt;判定数字机制&lt;/h1&gt;
&lt;p&gt;第一个1/1&lt;br&gt;
第二个1/2&lt;br&gt;
第三个1/3&lt;br&gt;
第四个1/4&lt;br&gt;
第五个1/5&lt;br&gt;
第六个1/6&lt;/p&gt;
&lt;h1 id=&#34;技能列表&#34;&gt;技能列表&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;冰冻：跳过杀人阶段&lt;/li&gt;
&lt;li&gt;近视：只能杀编号相邻的人（没有编号相邻的人就杀不了QWQ）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;游戏代码&#34;&gt;游戏代码：&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//LIVE
#include&amp;lt;bits/stdc++.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;conio.h&amp;gt;
using namespace std;
void print(char a[]){for(int i=0;i&amp;lt;strlen(a);i++){cout&amp;lt;&amp;lt;a[i];Sleep(10);}puts(&amp;quot;&amp;quot;);}
void cls(){system(&amp;quot;cls&amp;quot;);}
void pause(){system(&amp;quot;pause&amp;quot;);}
void hehe(){print(&amp;quot;小朋友想走不当途径是不好的&amp;quot;);print(&amp;quot;你死了&amp;quot;);exit(1);}
int f,a,last,live[10000],skill[10000];
int main(){
	srand(time(NULL));
	system(&amp;quot;title LIVE-by black_white&amp;quot;);
	system(&amp;quot;MODE CON: COLS=50 LINES=30&amp;quot;);
	std::srand(time(NULL));
	print(&amp;quot;LIVE活着&amp;quot;);pause();cls();
	print(&amp;quot;by 黑_白（永远的CC）&amp;quot;);pause();cls();
	printf(&amp;quot;输入人数（推荐7人）：&amp;quot;);
	cin&amp;gt;&amp;gt;last;
	if(last&amp;lt;=0)hehe();
	for(int i=1;i&amp;lt;=last;i++)live[i]=i;
	print(&amp;quot;规则：一共n个人，每个人选择一个击杀目标，最后剩下的人胜利&amp;quot;);pause();cls();
	print(&amp;quot;游戏开始！&amp;quot;);cls();
	printf(&amp;quot;输入你的编号（1~n）：&amp;quot;);
	cin&amp;gt;&amp;gt;a;cls();
	if(a==114514)print(&amp;quot;成功开启人机对打！&amp;quot;);
	else if(!(a&amp;gt;=1&amp;amp;&amp;amp;a&amp;lt;=last))hehe();
	cls();
	for(int I=1;;I++){
		cls();
		printf(&amp;quot;--------------------------------------------------\n&amp;quot;);
		printf(&amp;quot;第%d个回合：\n&amp;quot;,I);
		for(int i=1;i&amp;lt;=last;i++){
			if(live[i]==0)continue;
			int Cnt=0;
			for(int j=1;j&amp;lt;=last;j++)if(live[j]!=0)Cnt++;
			printf(&amp;quot;还剩%d人\n&amp;quot;,Cnt);
			printf(&amp;quot;还活着的人：&amp;quot;);
			for(int j=1;j&amp;lt;=last;j++)if(live[j]!=0)printf(&amp;quot;%d &amp;quot;,live[j]);
			puts(&amp;quot;&amp;quot;);
			if(skill[i]==1){
				printf(&amp;quot;%d号解冻\n&amp;quot;,i);
				skill[i]=0;
				continue;
			}
			int mb=rand()%(last+1);
			while(live[mb]==0&amp;amp;&amp;amp;mb==i&amp;amp;&amp;amp;mb==0)mb=rand()%(last+1);
			if(a!=live[i])printf(&amp;quot;%d选择了%d号\n&amp;quot;,live[i],live[mb]);
			else{
				printf(&amp;quot;你的目标是（输入0放弃猎杀）：&amp;quot;);
				cin&amp;gt;&amp;gt;mb;
				bool ff=0;
				for(int j=1;j&amp;lt;=last;j++)if(live[j]==mb)ff=1;
				if(!ff)hehe();
			}
			if(mb==0){
				print(&amp;quot;他放弃了猎杀...&amp;quot;);
				getch();
				continue;
			}
			if(skill[i]==2){
				if(mb-i&amp;gt;1||mb-i&amp;lt;-1){
					print(&amp;quot;近视生效...&amp;quot;);
					print(&amp;quot;打不到目标...&amp;quot;);
					skill[i]=0;
					continue;
				}
				skill[i]=0;
			}
			print(&amp;quot;正在生成判定数字...\n&amp;quot;);
			int pd[7],cnt=1;memset(pd,0,sizeof(pd));
			for(int j=1;j&amp;lt;=6;j++){
				int t=rand()%j;
				if(t!=0)break;
				int tt=rand()%6;
				pd[cnt]=tt;
				cnt++;
			}
			printf(&amp;quot;可判定的数字为：&amp;quot;);
			for(int j=1;j&amp;lt;=cnt;j++)pd[j]++,printf(&amp;quot;%d &amp;quot;,pd[j]);
			puts(&amp;quot;&amp;quot;);
			int s=rand()%3;
			if(s==0){
				print(&amp;quot;有人篡改了判定数字。&amp;quot;);
				pd[rand()%cnt+1]=rand()%6+1;
				printf(&amp;quot;现可判定的数字为：&amp;quot;);
				for(int j=1;j&amp;lt;=cnt;j++)printf(&amp;quot;%d &amp;quot;,pd[j]);
				puts(&amp;quot;&amp;quot;);
			}
			getch();
			int sz=rand()%6;sz++;
			printf(&amp;quot;%d号抛出了%d\n&amp;quot;,live[i],sz);
			bool kill=0;
			for(int i=1;i&amp;lt;=cnt;i++)
				if(sz==pd[i]){
					kill=1;
					break;
				}
			if(!kill)print(&amp;quot;未杀死目标。\n&amp;quot;),getch();
			else{
				int ttt=rand()%3;
				if(ttt&amp;gt;0){
					live[mb]=0,print(&amp;quot;成功杀死目标！\n&amp;quot;);
					int tttt=rand()%2;
					if(tttt){
						int mb3=rand()%(last+1);
						while(live[mb3]==0&amp;amp;&amp;amp;mb3==i&amp;amp;&amp;amp;mb3==0)mb3=rand()%(last+1);
						printf(&amp;quot;并发动技能：&amp;quot;);
						int aa=rand()%2;
						if(aa==0){
							printf(&amp;quot;冻结\n&amp;quot;);
							printf(&amp;quot;%d号被冻结了。\n&amp;quot;,mb3);
							skill[mb3]=1;
						}else if(aa==1){
							printf(&amp;quot;近视\n&amp;quot;);
							printf(&amp;quot;%d号近视了。\n&amp;quot;,mb3);
							skill[mb3]=2;
						}
					}
					getch();
				}
				else{
					int mb2=rand()%(last+1);
					while(live[mb2]==0&amp;amp;&amp;amp;mb==mb2&amp;amp;&amp;amp;mb2==0)mb2=rand()%(last+1);
					printf(&amp;quot;%d号复活了，并随机诅咒了%d号\n&amp;quot;,live[mb],live[mb2]);
					getch();
					int tttt=rand()%2;
					if(tttt)printf(&amp;quot;%d号死了\n&amp;quot;,live[mb2]),live[mb2]=0;
					else printf(&amp;quot;但他没死。\n\n&amp;quot;);
					getch();
				}
			}
			int sum=0;
			for(int i=1;i&amp;lt;=last;i++)if(live[i]!=0)sum++;
			if(sum==0){
				cls();
				print(&amp;quot;每个人都倒下了...&amp;quot;);
				print(&amp;quot;无人胜利...&amp;quot;);
				pause();
				return 0;
			}
			if(sum==1){
				for(int k=1;k&amp;lt;=last;k++)
					if(live[k]!=0){
						printf(&amp;quot;%d挺到了最后...\n&amp;quot;,live[k]);
						if(k==a)print(&amp;quot;你胜利了！&amp;quot;);
						pause();
						return 0;
					}
			}
		}
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">LIVE-活着</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/ren-lei-lun-xian-shi-shi-ji-ju-zuo/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;黑_白(永远的CC)和段建泽共同出品。&lt;/p&gt;
&lt;h1 id=&#34;剧情&#34;&gt;剧情&lt;/h1&gt;
&lt;h2 id=&#34;总剧情&#34;&gt;总剧情&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在千年以前，有一群人类被感染成了异种&lt;br&gt;
它们变得与常人不同,拥有更强大的力量与更强大的身体&lt;br&gt;
正常人类带着排斥接受着它们&lt;br&gt;
不知过了多久，人类异种窃取了正常人类的技术，但仍然没能继承人类的人性&lt;br&gt;
人类异种YZ带着他的亲卫队，妄图与创世主CC抗衡，夺取世界能量的来源——定界石&lt;br&gt;
那次人类使出了全力对抗异种&lt;br&gt;
双方死伤惨重,人类花了200年才恢复过来&lt;br&gt;
而人类异种从此销声匿迹&lt;br&gt;
但现在，他们卷土重来了！！！&lt;br&gt;
作为人类守护联盟的盟主，你能否担起重任，像千年以前的CC一样拯救世界？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;分剧情1default最后堡垒&#34;&gt;分剧情1：default:最后堡垒&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这是人类最后的希望...&lt;br&gt;
你将坚守最后的城池，保卫身后那颗普蓝色的定界石&lt;br&gt;
这个阶段，史称&lt;br&gt;
最后堡垒!!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;分剧情2beta失落城邦&#34;&gt;分剧情2：beta:失落城邦&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;人类从曾经摔倒的地方重新站起&lt;br&gt;
我们即将迎来第一场反击战!&lt;br&gt;
目光灼灼地望向前方，那曾是我们的家园&lt;br&gt;
这个阶段，史称&lt;br&gt;
失落城邦!!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;攻略&#34;&gt;攻略&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;首先，你可以一直按0大约10次，攒到大约200
然后，你可以建一层护盾和一个哨兵塔，用来进攻
接着，继续攒钱，建高射炮来防御坦克及飞机
最后，只需要在建筑有破损时重建就行了
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;各世界属性&#34;&gt;各世界属性&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;造物主模式初始资源很多
生存模式资源中等
衰竭模式资源匮乏，每回合我方扣固定的100血量
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;tips&#34;&gt;Tips&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;高射炮不仅可以打飞机，把它压下来也可以打地面敌人！
迫击炮不仅可以打小兵，还能打敌方基地！
小兵打敌方基地的伤害十分可观。
导弹可以直接打对方的基地！
千万别让小兵接近你的基地，你的建筑十分危险！
激光炮可以攻击小兵、坦克、飞机或直接进攻敌方，十分强大！
护盾可以抵挡敌方的一次远程进攻哦！
克隆法术可以将小兵数量变成原来的两倍，在关键时刻能起到意想不到的作用
岩石地雷可以在五回合后炸死敌方所有小兵哦！
晶坷垃是一种新型货币，不可与金币互换。
头铁少年破盾，钻地少年清兵。但需要耗费晶坷垃，且没有动静。
歼击机攻击力极高，无法被防御塔击毁，需要谨慎防备。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;游戏代码&#34;&gt;游戏代码&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;conio.h&amp;gt;
#include&amp;lt;iomanip&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;ctime&amp;gt;
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;conio.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include&amp;lt;mmsystem.h&amp;gt;
//#pragma comment(lib, &amp;quot;winmm.lib&amp;quot;)
using namespace std;
int e,g=50,o1=3000,o2,e1=3000,e2,o1_max=3000,Lv;//金币：g, 晶坷垃 jkl
int s,l,sl,pj,dd,i,ts,k,tk,tke,tkk,xx,bt,gs,fj,fje,jjj,jjje;
int fk,jg,jk,hd,hde,jd,jde,zx,iii,pz,lzpz,pze,lzpze;
int dl,dle,jkl,jkl_kc,tt,zd,reblood,water;
//bdaguai
int Rand;
int dgsr;
int fy=15;
int gj=30;
int Rand2;
int hp=100;
int gwhp;
int moneyrand;
int jbrand;
int jklrand;
int mjrand;
int gfrand;
int grand;
int frand;
int dgcs;
//bdaguai
int hxcs;
//kaibx
int ksr;
int gbrand1;
int jklrand1;
int Rand1;
int gfrand1;
int grand1;
int frand1;
int kxcs;
int zjay;//买到终极宝箱（终极奥义）1
int fxjs;//买宝箱20次  （奉献精神）1
int gwlr;//杀死20个怪  （怪物猎人）1
int hxds;//买回血器5个 （回血大师）1
int dgds;//打死十级怪物（打怪大师）1
//（打怪大师）
//（终极奥义）
//（奉献精神）
//（怪物猎人）
//（回血大师）
//kaibx
//2048
int game_answer=0;
//2048
char d,ch;
bool beta;
string ssss;
//cj
int qqqq;
int www,jjj1,zzz,lll,vvv,hhh;
int cjcs;
//cj
/*设置背景颜色*/int setBackColor(unsigned char bColor){
    HANDLE hd = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    GetConsoleScreenBufferInfo(hd, &amp;amp;csbInfo);
    return SetConsoleTextAttribute(hd, (bColor &amp;lt;&amp;lt; 4) | (csbInfo.wAttributes&amp;amp;~0xF0));
}
void appGotoXY(int x,int y)  //移动光标
{
    swap(x,y);
    CONSOLE_SCREEN_BUFFER_INFO    csbiInfo;
    HANDLE    hConsoleOut;
    hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hConsoleOut,&amp;amp;csbiInfo);
    csbiInfo.dwCursorPosition.X = x;
    csbiInfo.dwCursorPosition.Y = y;
    SetConsoleCursorPosition(hConsoleOut,csbiInfo.dwCursorPosition);
}
void appGetXY() //得到光标位置
{
    HANDLE hStdout;
    CONSOLE_SCREEN_BUFFER_INFO pBuffer;
    hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hStdout, &amp;amp;pBuffer);
    cout &amp;lt;&amp;lt; pBuffer.dwCursorPosition.X &amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt; pBuffer.dwCursorPosition.Y &amp;lt;&amp;lt;endl;;
}
/*设置字体颜色*/int setTextColor(unsigned char fColor){
    HANDLE hd = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    GetConsoleScreenBufferInfo(hd, &amp;amp;csbInfo);
    return SetConsoleTextAttribute(hd, fColor | (csbInfo.wAttributes&amp;amp;~0x0F));
}
void START(){
    appGotoXY(0,0);
    setBackColor(15);//大背景颜色
    for(int i=1;i&amp;lt;=26*80;i++)
        cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    appGotoXY(0,0);
    cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    appGotoXY(20,19);
    setBackColor(7);//小背景颜色
    for(int i=1;i&amp;lt;=42;i++)
        cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    setTextColor(0);//字体颜色
    appGotoXY(3,19);
    printf(&amp;quot;┏━━━━┳━━━━┳━━━━┳━━━━┓\n&amp;quot;);
    appGotoXY(4,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(5,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(6,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(7,19);
    printf(&amp;quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&amp;quot;);
    appGotoXY(8,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(9,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(10,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(11,19);
    printf(&amp;quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&amp;quot;);
    appGotoXY(12,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(13,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(14,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(15,19);
    printf(&amp;quot;┣━━━━╋━━━━╋━━━━╋━━━━┫\n&amp;quot;);
    appGotoXY(16,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(17,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(18,19);
    printf(&amp;quot;┃        ┃        ┃        ┃        ┃\n&amp;quot;);
    appGotoXY(19,19);
    printf(&amp;quot;┗━━━━┻━━━━┻━━━━┻━━━━┛\n&amp;quot;);
    //Sleep(100000);
    return ;
}
inline int Get_X(int x,int y){
    if(x==1)    return 5;
    if(x==2)    return 9;
    if(x==3)    return 13;
    if(x==4)    return 17;
}
inline int Get_Y(int x,int y){
    if(y==1)    return 24;
    if(y==2)    return 34;
    if(y==3)    return 44;
    if(y==4)    return 54;
}

void HideCursor(){//隐藏光标
    CONSOLE_CURSOR_INFO cursor_info = {1, 0};
    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;amp;cursor_info);
}

int a[5][5];
bool if_game_over(){
    for(int i=1;i&amp;lt;=4;i++)
        for(int j=1;j&amp;lt;=4;j++)
            if(!a[i][j])
                return 1;
    for(int i=2;i&amp;lt;=4;i++)
        for(int j=1;j&amp;lt;=4;j++){
            if(a[j][i]==a[j][i-1])
                return 1;
            if(a[i][j]==a[i-1][j])
                return 1;
        }
    return 0;
}
bool vis[20];

void Pr_a_num_with_color(int x){
    switch (x){/*
        1 = 蓝色   9  = 淡蓝色
        2 = 绿色   10 = 淡绿色
        3 = 湖蓝色 11 = 淡浅绿色
        4 = 红色   12 = 淡红色
        5 = 紫色   13 = 淡紫色
        6 = 黄色   14 = 淡黄色
        7 = 白色   15 = 亮白色*/
        case 2:setTextColor(9);printf(&amp;quot;CE&amp;quot;);setTextColor(0);break ;
        case 4:setTextColor(10);printf(&amp;quot;RE&amp;quot;);setTextColor(0);break ;
        case 8:setTextColor(11);printf(&amp;quot;TLE&amp;quot;);setTextColor(0);break ;
        case 16:setTextColor(12);printf(&amp;quot;MLE&amp;quot;);setTextColor(0);break ;
        case 32:setTextColor(13);printf(&amp;quot;ILE&amp;quot;);setTextColor(0);break ;
        case 64:setTextColor(14);printf(&amp;quot;OLE&amp;quot;);setTextColor(0);break ;
        case 128:setTextColor(15);printf(&amp;quot;UKE&amp;quot;);setTextColor(0);break ;
        case 256:setTextColor(1);printf(&amp;quot;WA&amp;quot;);setTextColor(0);break ;
        case 512:setTextColor(2);printf(&amp;quot;AC&amp;quot;);setTextColor(0);break ;
        case 1024:setTextColor(3);printf(&amp;quot;AU&amp;quot;);setTextColor(0);break ;
        case 2048:setTextColor(4);printf(&amp;quot;AK&amp;quot;);setTextColor(0);break ;
    }
}

void Pr_all_num(){
    for(int i=1;i&amp;lt;=4;i++)
        for(int j=1;j&amp;lt;=4;j++){
            int x=Get_X(i,j),y=Get_Y(i,j);
            appGotoXY(x,y);
            if(a[i][j]==0)
                printf(&amp;quot;    &amp;quot;);
            else{
                Pr_a_num_with_color(a[i][j]);
                //printf(&amp;quot;%4d&amp;quot;,a[i][j]);
            }
        }
    return ;
}
//**************************************************
bool clear_up(){
    bool bb=0;
    for(int k=1;k&amp;lt;=4;k++)
        for(int i=3;i&amp;gt;=1;i--)
            for(int j=1;j&amp;lt;=4;j++)
                if(a[i][j]==0&amp;amp;&amp;amp;a[i+1][j]!=0){
                    swap(a[i][j],a[i+1][j]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_up(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_up())//没空间不能移动
        bb=0;
    for(int j=1;j&amp;lt;=4;j++){
        int i=1;
        while(i&amp;lt;4){
            if(!a[i+1][j])
                break ;
            if(a[i][j]!=a[i+1][j]){
                i++;
                continue ;
            }
            if(a[i][j]==a[i+1][j]){
                a[i][j]+=a[i+1][j]; game_answer+=a[i+1][j];
                a[i+1][j]=0;
                i+=2;
                bb=1;//可以合并
            }
        }
    }
    if(bb==0)//没空间又不能合并
        return 0;
    clear_up();
    return 1;
}
//**************************************************
bool clear_down(){
    bool bb=0;
    for(int k=1;k&amp;lt;=4;k++)
        for(int i=2;i&amp;lt;=4;i++)
            for(int j=1;j&amp;lt;=4;j++)
                if(a[i][j]==0&amp;amp;&amp;amp;a[i-1][j]!=0){
                    swap(a[i][j],a[i-1][j]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_down(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_down())
        bb=0;
    for(int j=1;j&amp;lt;=4;j++){
        int i=4;
        while(i&amp;gt;1){
            if(!a[i-1][j])
                break ;
            if(a[i][j]!=a[i-1][j]){
                i--;
                continue ;
            }
            if(a[i][j]==a[i-1][j]){
                a[i][j]+=a[i-1][j];  game_answer+=a[i-1][j];
                a[i-1][j]=0;
                i-=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_down();
    return 1;
}
//**************************************************
bool clear_left(){
    bool bb=0;
    for(int k=1;k&amp;lt;=4;k++)
        for(int i=1;i&amp;lt;=4;i++)
            for(int j=3;j&amp;gt;=1;j--)
                if(a[i][j]==0&amp;amp;&amp;amp;a[i][j+1]!=0){
                    swap(a[i][j],a[i][j+1]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_left(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_left())
        bb=0;
    for(int i=1;i&amp;lt;=4;i++){
        int j=1;
        while(j&amp;lt;4){
            if(!a[i][j+1])
                break ;
            if(a[i][j]!=a[i][j+1]){
                j++;
                continue ;
            }
            if(a[i][j]==a[i][j+1]){
                a[i][j]+=a[i][j+1];  game_answer+=a[i][j+1];
                a[i][j+1]=0;
                j+=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_left();
    return 1;
}
//**************************************************
bool clear_right(){
    bool bb=0;
    for(int k=1;k&amp;lt;=4;k++)
        for(int i=1;i&amp;lt;=4;i++)
            for(int j=2;j&amp;lt;=4;j++)
                if(a[i][j]==0&amp;amp;&amp;amp;a[i][j-1]!=0){
                    swap(a[i][j],a[i][j-1]);
                    bb=1;
                }
    if(bb==1)
        return 1;
    return 0;
}
bool do_right(){
    if(!if_game_over())
        return 1;
    bool bb=1;
    if(!clear_right())
        bb=0;
    for(int i=1;i&amp;lt;=4;i++){
        int j=4;
        while(j&amp;gt;1){
            if(!a[i][j-1])
                break ;
            if(a[i][j]!=a[i][j-1]){
                j--;
                continue ;
            }
            if(a[i][j]==a[i][j-1]){
                a[i][j]+=a[i][j-1];  game_answer+=a[i][j-1];
                a[i][j-1]=0;
                j-=2;
                bb=1;
            }
        }
    }
    if(bb==0)
        return 0;
    clear_right();
    return 1;
}
void END(){
    setBackColor(15);
    appGotoXY(21,30);
    char s_1[30]=&amp;quot;游戏结束，您的得分为：&amp;quot;;
    for(int i=0;i&amp;lt;22;i++){
        cout&amp;lt;&amp;lt;s_1[i];
        Sleep(30);
    }
    Sleep(500);
    cout&amp;lt;&amp;lt;game_answer&amp;lt;&amp;lt;endl;
    g+=game_answer;
    Sleep(500);
    appGotoXY(22,30);
    char s_2[30]=&amp;quot;请按任意键结束游戏。&amp;quot;;
    for(int i=0;i&amp;lt;20;i++){
        cout&amp;lt;&amp;lt;s_2[i];
        Sleep(30);
    }
}
void rlsb(){
    srand(time(0));
    HideCursor();//隐藏光标

    START();

    while(if_game_over()){
        //system(&amp;quot;cls&amp;quot;);
        //appGotoXY(0,0);

        int bb=0;//bb判断是否有空位
        for(int i=1;i&amp;lt;=4;i++)
            for(int j=1;j&amp;lt;=4;j++)
                if(!a[i][j])
                    bb=1;
        if(bb==1){
            int num_new=rand()%10+1;//新出现4还是2
            if(num_new==1)  num_new=4;
            else    num_new=2;
            int place_new=0,x=0,y=0;
            while(1){
                place_new=rand()%16+1;
                x=(place_new-1)/4+1,y=place_new%4+1;
                if(!a[x][y])
                    break ;
            }
            a[x][y]=num_new;
        }

        Pr_all_num();

    again:
        char ch_1=getch(),ch_2;
        if(ch_1!=-32){
            appGotoXY(20,30);
            char s_1[30]=&amp;quot;您输入的字符不合法。&amp;quot;;
            for(int i=0;i&amp;lt;20;i++){
                cout&amp;lt;&amp;lt;s_1[i];
                Sleep(1);
            }
            Sleep(200);
            for(int i=1;i&amp;lt;=19;i++)
                printf(&amp;quot;\b \b&amp;quot;);
            goto again;
        }
        ch_2=getch();
        if(ch_2==72)//up
            if(!do_up())
                goto again;
        if(ch_2==80)//down
            if(!do_down())
                goto again;
        if(ch_2==75)//left
            if(!do_left())
                goto again;
        if(ch_2==77)//right
            if(!do_right())
                goto again;
        appGotoXY(20,30);
        printf(&amp;quot;您当前的总分为:%d&amp;quot;,game_answer);
    }
    appGotoXY(20,30);
    printf(&amp;quot;                     &amp;quot;);
    END();
    return;
}
void cj(){
	system(&amp;quot;cls&amp;quot;);
	while(1){
		giao:
		system(&amp;quot;cls&amp;quot;);
		printf(&amp;quot;0 退出\n&amp;quot;);
		printf(&amp;quot;1 查看几率\n&amp;quot;);
		printf(&amp;quot;2 抽奖\n&amp;quot;);
		printf(&amp;quot;纯属娱乐\n&amp;quot;);
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;qqqq);
		if(qqqq==0) return;
		if(qqqq==1){
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;200次%65几率抽到金色传说，%10抽中透明无敌\n&amp;quot;);
			printf(&amp;quot;100次%30几率抽到金色传说，%5抽中透明无敌\n&amp;quot;);
			printf(&amp;quot;50次%15几率抽到金色传说，%2抽中透明无敌\n&amp;quot;);
			printf(&amp;quot;10次%4几率抽到金色传说，%1抽中透明无敌\n&amp;quot;);
			printf(&amp;quot;5次%2几率抽中金色传说，%0.5抽中透明无敌\n&amp;quot;);
			printf(&amp;quot;1次%0.4几率抽中金色传说，%0.1抽中透明无敌\n&amp;quot;);
			Sleep(5000);
		}else if(qqqq==2){
			printf(&amp;quot;输入次数：\n&amp;quot;);
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;cjcs);
			if(g&amp;lt;cjcs*5){
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;钱不够\n&amp;quot;);
				Sleep(5000);
				goto giao;
			}else{
				system(&amp;quot;cls&amp;quot;);
				g-=cjcs*5;
				while(cjcs--){
					int x=std::rand()%1000*rand()%10000;
					if(x&amp;lt;=1){
						printf(&amp;quot;透明无敌！！！\n&amp;quot;);
						MessageBox(NULL,&amp;quot;你竟然抽中了爆率为%0.1的透明无敌！&amp;quot;,&amp;quot;透明无敌！&amp;quot;,MB_OK);
						www++;
						goto f;
					}
					if(x&amp;lt;=30){
						printf(&amp;quot;金色传说！\n&amp;quot;);
						MessageBox(NULL,&amp;quot;金色传说&amp;quot;,&amp;quot;nb&amp;quot;,MB_OK);
						jjj1++;
						goto f;
					}
					if(x&amp;lt;=100){
						printf(&amp;quot;紫色史诗\n&amp;quot;);
						zzz++;
						goto f;
					}
					if(x&amp;lt;=1000){
						printf(&amp;quot;蓝色精英\n&amp;quot;);
						lll++;
						goto f;
					}
					if(x&amp;lt;=2000){
						printf(&amp;quot;绿色普通\n&amp;quot;);
						vvv++;
						goto f;
					}
					printf(&amp;quot;灰色渣渣\n&amp;quot;),hhh++;
					f:
					Sleep(30);
				}
				printf(&amp;quot;透明无敌：%d\n&amp;quot;,www);
				printf(&amp;quot;金色传说：%d\n&amp;quot;,jjj1);
				printf(&amp;quot;紫色史诗：%d\n&amp;quot;,zzz);
				printf(&amp;quot;蓝色精英：%d\n&amp;quot;,lll);
				printf(&amp;quot;绿色普通：%d\n&amp;quot;,vvv);
				printf(&amp;quot;灰色渣渣：%d\n&amp;quot;,hhh);
				Sleep(3000);
				goto giao;
			}
		}
	}
}
void kaibx(){
	bugo:
	if(kxcs&amp;gt;=20&amp;amp;&amp;amp;fxjs!=1){
		fxjs=1;
		system(&amp;quot;cls&amp;quot;);
		printf(&amp;quot;恭喜你取得了奉献精神的成就！！！\n&amp;quot;);
		Sleep(5000);
		printf(&amp;quot;奖励50晶坷垃,150金币&amp;quot;);
		g+=150;
		jkl+=50;
		Sleep(5000);
	}
	system(&amp;quot;cls&amp;quot;);
	printf(&amp;quot;▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉\n&amp;quot;);
	printf(&amp;quot;▉                宝箱                ▉\n&amp;quot;);
	printf(&amp;quot;▉1.  木头宝箱（10金币）              ▉\n&amp;quot;);
	printf(&amp;quot;▉2.  白银宝箱（20金币）              ▉\n&amp;quot;);
	printf(&amp;quot;▉3.  黄金宝箱（20金币，10晶坷垃）    ▉\n&amp;quot;);
	printf(&amp;quot;▉4.  钻石宝箱（50金币，20晶坷垃）    ▉\n&amp;quot;);
	printf(&amp;quot;▉5.  电击宝箱（100金币，40晶坷垃）   ▉\n&amp;quot;);
	printf(&amp;quot;▉6.  雷电宝箱（500金币，100晶坷垃）  ▉\n&amp;quot;);
	printf(&amp;quot;▉7.  终极宝箱（5000金币，500晶坷垃） ▉\n&amp;quot;);
	printf(&amp;quot;▉8.  退出                            ▉\n&amp;quot;);
	printf(&amp;quot;▉▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▉\n&amp;quot;);
	printf(&amp;quot;  金币：%d                              \n&amp;quot;,g);
	printf(&amp;quot;  晶坷垃：%d                            \n&amp;quot;,jkl);
	printf(&amp;quot;  开箱次数：%d                          \n&amp;quot;,kxcs);
	printf(&amp;quot;▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉\n&amp;quot;);
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;ksr);
	if(ksr==0){
		return;
	}
	if(ksr==1){
		if(g&amp;gt;=10){
			kxcs++;
			g-=10;
			Rand1=std::rand()%2;
			if(Rand1==1){
				gbrand1=std::rand()%15+5;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d金币\n&amp;quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else{
				jklrand1=std::rand()%6+2;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d晶坷垃&amp;quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}
		}else{
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;钱不够\n&amp;quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==2){
		if(g&amp;gt;=20){
			kxcs++;
			g-=20;
			Rand1=std::rand()%2;
			if(Rand1==1){
				gbrand1=std::rand()%25+10;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d金币\n&amp;quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else{
				jklrand1=std::rand()%15+5;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d晶坷垃&amp;quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}
		}else{
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;钱不够\n&amp;quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==3){
		if(g&amp;gt;=20 &amp;amp;&amp;amp; jkl&amp;gt;=10){
			kxcs++;
			g-=20;
			jkl-=10;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%35+25;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d金币\n&amp;quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%15+15;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d晶坷垃&amp;quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&amp;quot;cls&amp;quot;);
					grand1=std::rand()%5+3;
					printf(&amp;quot;奖励%d攻击力&amp;quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&amp;quot;cls&amp;quot;);
					frand1=std::rand()%5+3;
					printf(&amp;quot;奖励%d防御力&amp;quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;钱不够\n&amp;quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==4){
		if(g&amp;gt;=50 &amp;amp;&amp;amp; jkl&amp;gt;=20){
			kxcs++;
			g-=50;
			jkl-=20;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%60+30;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d金币\n&amp;quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%40+30;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d晶坷垃&amp;quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&amp;quot;cls&amp;quot;);
					grand1=std::rand()%10+5;
					printf(&amp;quot;奖励%d攻击力&amp;quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&amp;quot;cls&amp;quot;);
					frand1=std::rand()%10+5;
					printf(&amp;quot;奖励%d防御力&amp;quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;钱不够\n&amp;quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==5){
		if(g&amp;gt;=100 &amp;amp;&amp;amp; jkl&amp;gt;=40){
			kxcs++;
			g-=100;
			jkl-=40;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%190+80;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d金币\n&amp;quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%100+40;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d晶坷垃&amp;quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&amp;quot;cls&amp;quot;);
					grand1=std::rand()%20+5;
					printf(&amp;quot;奖励%d攻击力&amp;quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&amp;quot;cls&amp;quot;);
					frand1=std::rand()%20+5;
					printf(&amp;quot;奖励%d防御力&amp;quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;钱不够\n&amp;quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==6){
		if(g&amp;gt;=500 &amp;amp;&amp;amp; jkl&amp;gt;=100){
			kxcs++;
			g-=500;
			jkl-=100;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%700+250;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d金币\n&amp;quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%250+70;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d晶坷垃&amp;quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&amp;quot;cls&amp;quot;);
					grand1=std::rand()%30+10;
					printf(&amp;quot;奖励%d攻击力&amp;quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&amp;quot;cls&amp;quot;);
					frand1=std::rand()%30+10;
					printf(&amp;quot;奖励%d防御力&amp;quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;钱不够\n&amp;quot;);
			Sleep(4000);
			goto bugo;
		}
	}
	else if(ksr==7){
		if(g&amp;gt;=5000 &amp;amp;&amp;amp; jkl&amp;gt;=500){
			if(zjay!=1){
				zjay=1;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;恭喜你取得了终极奥义的成就！！！\n&amp;quot;);
				Sleep(5000);
				printf(&amp;quot;奖励100晶坷垃,500金币&amp;quot;);
				g+=500;
				jkl+=100;
				Sleep(5000);
			}
			kxcs++;
			g-=5000;
			jkl-=500;
			Rand1=std::rand()%3;
			if(Rand1==1){
				gbrand1=std::rand()%5000+3500;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d金币\n&amp;quot;,gbrand1);
				g+=gbrand1;
				Sleep(4000);
				goto bugo;
			}else if(Rand1==2){
				jklrand1=std::rand()%2000+700;
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;奖励%d晶坷垃&amp;quot;,jklrand1);
				jkl+=jklrand1;
				Sleep(4000);
				goto bugo;
			}else{
				gfrand=std::rand()%2;
				if(gfrand==1){
					system(&amp;quot;cls&amp;quot;);
					grand1=std::rand()%100+30;
					printf(&amp;quot;奖励%d攻击力&amp;quot;,grand1);
					gj+=grand1;
					Sleep(4000);
					goto bugo;
				}else{
					system(&amp;quot;cls&amp;quot;);
					frand1=std::rand()%100+30;
					printf(&amp;quot;奖励%d防御力&amp;quot;,frand1);
					fy+=frand1;
					Sleep(4000);
					goto bugo;
				}
			}
		}else{
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;钱不够\n&amp;quot;);
			Sleep(4000);
			goto bugo;
		}
	}
}
void bdaguai(){
	shengli:
	if(dgcs&amp;gt;=20&amp;amp;&amp;amp;gwlr!=1){
		gwlr=1;
		system(&amp;quot;cls&amp;quot;);
		printf(&amp;quot;恭喜你取得了怪物猎人的成就！！！\n&amp;quot;);
		Sleep(5000);
		printf(&amp;quot;奖励20晶坷垃,100金币&amp;quot;);
		g+=100;
		jkl+=20;
		Sleep(5000);
	}
	system(&amp;quot;cls&amp;quot;);
	printf(&amp;quot;杀死怪物：%d\n&amp;quot;,dgcs);
	printf(&amp;quot;血量：%d\n&amp;quot;,hp);
	printf(&amp;quot;攻击力：%d\n&amp;quot;,gj);
	printf(&amp;quot;防御力：%d\n&amp;quot;,fy);
	printf(&amp;quot;1. 购买血瓶(10$/20hp)\n&amp;quot;);
	printf(&amp;quot;2. 返回\n&amp;quot;);
	printf(&amp;quot;3. 继续\n&amp;quot;);
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;dgsr);
	if(dgsr==2) return;
	else if(dgsr==1){
		if(g&amp;lt;20){
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;钱不够\n&amp;quot;);
			Sleep(2000);
			goto shengli;
		}else{
			g-=10;
			hp+=20;
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;回血成功\n&amp;quot;);
			Sleep(2000);
			goto shengli;
		}
	}else if(dgsr==3){
		system(&amp;quot;cls&amp;quot;);
		if(hp&amp;lt;=0){
			system(&amp;quot;cls&amp;quot;);
			printf(&amp;quot;血量不足无法冒险\n&amp;quot;);
			printf(&amp;quot;1. 购买血瓶(10$/20hp)\n&amp;quot;);
			printf(&amp;quot;2. 返回\n&amp;quot;);
			scanf(&amp;quot;%d&amp;quot;,&amp;amp;dgsr);
			if(dgsr==2) return;
			else{
				if(g&amp;lt;20){
					system(&amp;quot;cls&amp;quot;);
					printf(&amp;quot;钱不够\n&amp;quot;);
					Sleep(2000);
					goto shengli;
				}else{
					g-=10;
					hp+=20;
					system(&amp;quot;cls&amp;quot;);
					printf(&amp;quot;回血成功\n&amp;quot;);
					Sleep(2000);
					goto shengli;
				}
			}
			return;
		}
		Rand=std::rand()%10+1;
		gwhp=Rand*30;
		printf(&amp;quot;你遇到了%d级怪物\n&amp;quot;,Rand);
		printf(&amp;quot;血量：%d\n&amp;quot;,hp);
		printf(&amp;quot;攻击力：%d\n&amp;quot;,gj);
		printf(&amp;quot;防御力：%d\n&amp;quot;,fy);
		printf(&amp;quot;怪物血量：%d\n&amp;quot;,gwhp);
		printf(&amp;quot;怪物攻击力：%d\n&amp;quot;,Rand*10);
		printf(&amp;quot;怪物防御力：%d\n&amp;quot;,Rand*5);
		printf(&amp;quot;1. 迎战\n&amp;quot;);
		printf(&amp;quot;2. 逃跑\n&amp;quot;);
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;dgsr);
		if(dgsr==2) goto shengli;
		else{
			while(1){
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;血量：%d\n&amp;quot;,hp);
				printf(&amp;quot;攻击力：%d\n&amp;quot;,gj);
				printf(&amp;quot;防御力：%d\n&amp;quot;,fy);
				printf(&amp;quot;怪物血量：%d\n&amp;quot;,gwhp);
				printf(&amp;quot;怪物攻击力：%d\n&amp;quot;,Rand*10);
				printf(&amp;quot;怪物防御力：%d\n&amp;quot;,Rand*5);
				printf(&amp;quot;1. 攻击\n&amp;quot;);
				printf(&amp;quot;2. 防御\n&amp;quot;);
				scanf(&amp;quot;%d&amp;quot;,&amp;amp;dgsr);
				if(dgsr==1){
					system(&amp;quot;cls&amp;quot;);
					Rand2=std::rand()%5;
					if(Rand2==0){
						system(&amp;quot;cls&amp;quot;);
						printf(&amp;quot;怪物暴击\n&amp;quot;);
						hp-=(Rand*20-fy);
						if(hp&amp;lt;=0){
							system(&amp;quot;cls&amp;quot;);
							printf(&amp;quot;KO\n&amp;quot;);
							Sleep(2000);
							return;
						}
						Sleep(2000);
					}else{
						hp-=(Rand*10-fy);
						if(hp&amp;lt;=0){
							system(&amp;quot;cls&amp;quot;);
							printf(&amp;quot;KO\n&amp;quot;);
							Sleep(2000);
							return;
						}
					}
					Rand2=std::rand()%5;
					if(Rand2==0){
						system(&amp;quot;cls&amp;quot;);
						printf(&amp;quot;暴击&amp;quot;);
						gwhp-=(gj*2-Rand*5);
						if(gwhp&amp;lt;=0){
							dgcs++;
							if(Rand==10) dgds=1;
							system(&amp;quot;cls&amp;quot;);
							printf(&amp;quot;胜利\n&amp;quot;);
							mjrand=std::rand()%3;
							if(mjrand==0){
								jbrand=std::rand()%(Rand*15)+5;
								printf(&amp;quot;奖励%d金币\n&amp;quot;,jbrand);
								g+=jbrand;
							}else if(mjrand==1){
								jklrand=std::rand()%(Rand*10)+1;
								printf(&amp;quot;奖励%d晶坷垃\n&amp;quot;,jklrand);
								jkl+=jklrand;
							}else{
								gfrand=std::rand()%2;
								if(gfrand==0){
									grand=std::rand()%(Rand*3)+1;
									printf(&amp;quot;增加%d攻击力\n&amp;quot;,grand);
									gj+=grand;
								}else{
									frand=std::rand()%(Rand*3)+1;
									printf(&amp;quot;增加%d防御力\n&amp;quot;,frand);
									fy+=frand;
								}
							}
							Sleep(2000);
							goto shengli;
						}
						Sleep(2000);
					}else{
						gwhp-=(gj-Rand*5);
						if(gwhp&amp;lt;=0){
							dgcs++;
							if(Rand==10 &amp;amp;&amp;amp; dgds!=1){
								dgds=1;
								system(&amp;quot;cls&amp;quot;);
								printf(&amp;quot;恭喜你取得了打怪大师的成就！！！\n&amp;quot;);
								Sleep(5000);
								printf(&amp;quot;奖励200晶坷垃,1000金币&amp;quot;);
								g+=1000;
								jkl+=200;
								Sleep(5000);
							}
							system(&amp;quot;cls&amp;quot;);
							printf(&amp;quot;胜利\n&amp;quot;);
							mjrand=std::rand()%5;
							if(mjrand==0){
								jbrand=std::rand()%(Rand*15)+5;
								printf(&amp;quot;奖励%d金币\n&amp;quot;,jbrand);
								g+=jbrand;

							}else if(mjrand==1){
								jklrand=std::rand()%(Rand*10)+5;
								printf(&amp;quot;奖励%d晶坷垃\n&amp;quot;,jklrand);
								jkl+=jklrand;
							}else{
								gfrand=std::rand()%2;
								if(gfrand==0){
									grand=std::rand()%(Rand*3)+1;
									printf(&amp;quot;增加%d攻击力\n&amp;quot;,grand);
									gj+=grand;
								}else{
									frand=std::rand()%(Rand*3)+1;
									printf(&amp;quot;增加%d防御力\n&amp;quot;,frand);
									fy+=frand;
								}
							}
							Sleep(2000);
							goto shengli;
						}
					}
				}
			}
		}
	}
}
void xs(char ccc){
	cout&amp;lt;&amp;lt;&amp;quot;金币数($)：&amp;quot;&amp;lt;&amp;lt;g&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;&amp;quot;晶坷垃(G)：&amp;quot;&amp;lt;&amp;lt;jkl&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;&amp;quot;我方人数：&amp;quot;&amp;lt;&amp;lt;o2+jde&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;&amp;quot;敌方人数：&amp;quot;&amp;lt;&amp;lt;e2+jd&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;&amp;quot;我方血量：&amp;quot;&amp;lt;&amp;lt;o1&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;&amp;quot;敌方血量：&amp;quot;&amp;lt;&amp;lt;e1&amp;lt;&amp;lt;endl;
	if(beta) cout&amp;lt;&amp;lt;&amp;quot;主塔级别：&amp;quot;&amp;lt;&amp;lt;Lv&amp;lt;&amp;lt;endl;
	if(ccc==&#39;3&#39;) cout&amp;lt;&amp;lt;&amp;quot;已生存天数：&amp;quot;&amp;lt;&amp;lt;iii&amp;lt;&amp;lt;endl;
	if(zx!=0) cout&amp;lt;&amp;lt;&amp;quot;已处于诈降状态&amp;quot;&amp;lt;&amp;lt;endl;
	return ;
}
void bg();
void aa(string sssss){
	if(e1&amp;lt;1000) bg();
	if(ssss==&amp;quot;16391639&amp;quot;){
		g=50000;
		e1=1000000;
		hd=10;
		o1=5000;
	}
	if(ssss!=&amp;quot;test&amp;quot;&amp;amp;&amp;amp;ssss!=&amp;quot;16391639&amp;quot;){
		cout&amp;lt;&amp;lt;&amp;quot;在千年以前，有一群人类被感染成了异种\n&amp;quot;;
		Sleep(2000);
		cout&amp;lt;&amp;lt;&amp;quot;它们变得与常人不同,拥有更强大的力量与更强大的身体\n&amp;quot;;
		Sleep(2000);
		cout&amp;lt;&amp;lt;&amp;quot;正常人类带着排斥接受着它们\n&amp;quot;;
		Sleep(2000);
		cout&amp;lt;&amp;lt;&amp;quot;不知过了多久，人类异种窃取了正常人类的技术，但仍然没能继承人类的人性\n&amp;quot;;
		Sleep(2000);
		cout&amp;lt;&amp;lt;&amp;quot;人类异种YZ带着他的亲卫队，妄图与创世主CC抗衡，夺取世界能量的来源——定界石\n&amp;quot;;
		Sleep(2000);
		cout&amp;lt;&amp;lt;&amp;quot;那次人类使出了全力对抗异种\n&amp;quot;;
		Sleep(2000);
		cout&amp;lt;&amp;lt;&amp;quot;双方死伤惨重,人类花了200年才恢复过来\n&amp;quot;;
		cout&amp;lt;&amp;lt;&amp;quot;而人类异种从此销声匿迹\n&amp;quot;;
		Sleep(2000);
		system(&amp;quot;cls&amp;quot;);
		cout&amp;lt;&amp;lt;&amp;quot;但现在，他们卷土重来了！！！&amp;quot;;
		Sleep(2000);
		system(&amp;quot;cls&amp;quot;);
		cout&amp;lt;&amp;lt;&amp;quot;作为人类守护联盟的盟主，你能否担起重任，像千年以前的CC一样拯救世界？&amp;quot;;
		Sleep(2000);
	}
	while(true){
		system(&amp;quot;cls&amp;quot;);
		cout&amp;lt;&amp;lt;&amp;quot;请选择模式\n&amp;quot;;
		cout&amp;lt;&amp;lt;&amp;quot;1 default:最后堡垒\n&amp;quot;;
		cout&amp;lt;&amp;lt;&amp;quot;2 beta:失落城邦\n&amp;quot;;
		ch=getch();
		system(&amp;quot;cls&amp;quot;);
		if(ch==&#39;1&#39;){
			if(MessageBox(NULL,&amp;quot;你真的要进入default模式吗？&amp;quot;,&amp;quot;提示&amp;quot;,MB_YESNO)==IDYES){
				cout&amp;lt;&amp;lt;&amp;quot;这是人类最后的希望...\n&amp;quot;;
				Sleep(2000);
				cout&amp;lt;&amp;lt;&amp;quot;你将坚守最后的城池，保卫身后那颗普蓝色的定界石\n&amp;quot;;
				Sleep(3500);
				cout&amp;lt;&amp;lt;&amp;quot;这个阶段，史称\n&amp;quot;;
				Sleep(1000);
				system(&amp;quot;cls&amp;quot;);
				cout&amp;lt;&amp;lt;&amp;quot;最后堡垒!!!\n&amp;quot;;
				break;
			}
		}
		else if(ch==&#39;2&#39;){
			if(MessageBox(NULL,&amp;quot;你真的要进入beta模式吗？&amp;quot;,&amp;quot;提示&amp;quot;,MB_YESNO)==IDYES){
				cout&amp;lt;&amp;lt;&amp;quot;人类从曾经摔倒的地方重新站起\n&amp;quot;;
				Sleep(2000);
				cout&amp;lt;&amp;lt;&amp;quot;我们即将迎来第一场反击战!\n&amp;quot;;
				Sleep(2000);
				cout&amp;lt;&amp;lt;&amp;quot;目光灼灼地望向前方，那曾是我们的家园\n&amp;quot;;
				Sleep(2000);
				cout&amp;lt;&amp;lt;&amp;quot;这个阶段，史称\n&amp;quot;;
				Sleep(2000);
				system(&amp;quot;cls&amp;quot;);
				cout&amp;lt;&amp;lt;&amp;quot;失落城邦!!!\n&amp;quot;;
				beta=true;
				break;
			}
		}
	}
	Sleep(2000);
	while(true){
		system(&amp;quot;cls&amp;quot;);
		if(!beta){
			cout&amp;lt;&amp;lt;&amp;quot;战争 7.5.7\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;1 攻略\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;2 各世界属性\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;3 造物主模式\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;4 生存模式\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;5 衰竭模式\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;6 普通模式\n&amp;quot;;
		}else{
			cout&amp;lt;&amp;lt;&amp;quot;战争-beta 1.2.1\n&amp;quot;;//beta模式版本号-6,-3,-6
			cout&amp;lt;&amp;lt;&amp;quot;开始\n&amp;quot;;
		}
		ch=getch();
		if(beta){
			system(&amp;quot;cls&amp;quot;);
			g=200;
			jkl=50;
			e1=8000;
			o1=5000;
			o1_max=5000;
			break;
		}
		if(!beta&amp;amp;&amp;amp;ch==&#39;1&#39;){
			cout&amp;lt;&amp;lt;char(7);
			cout&amp;lt;&amp;lt;&amp;quot;首先，你可以一直按0大约10次，攒到大约200\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;然后，你可以建一层护盾和一个哨兵塔，用来进攻\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;接着，继续攒钱，建高射炮来防御坦克及飞机\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;最后，只需要在建筑有破损时重建就行了\n&amp;quot;;
			getch();
		}
		else if(!beta&amp;amp;&amp;amp;ch==&#39;2&#39;){
			system(&amp;quot;cls&amp;quot;);
			cout&amp;lt;&amp;lt;&amp;quot;造物主模式初始资源很多\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;生存模式资源中等\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;衰竭模式资源匮乏，每回合我方扣固定的100血量\n&amp;quot;;
			Sleep(5000);
		}
		else if(!beta&amp;amp;&amp;amp;ch==&#39;3&#39;){
			system(&amp;quot;cls&amp;quot;);
			g=10000;
			jkl=500;
			e1=100000;
			hd=10;
			o1=5000;
			o1_max=5000;
			break;
		}
		else if(!beta&amp;amp;&amp;amp;ch==&#39;4&#39;){
			system(&amp;quot;cls&amp;quot;);
			g=1000;
			e1=100000;
			hd=5;
			o1=5000;
			o1_max=5000;
			break;
		}
		else if(!beta&amp;amp;&amp;amp;ch==&#39;5&#39;){
			system(&amp;quot;cls&amp;quot;);
			e=100;
			break;
		}
		else if(!beta&amp;amp;&amp;amp;ch==&#39;@&#39;){
			cout&amp;lt;&amp;lt;char(7)&amp;lt;&amp;lt;char(7)&amp;lt;&amp;lt;char(7)&amp;lt;&amp;lt;char(7);
			cout&amp;lt;&amp;lt;&amp;quot;此版本已上传至永远的CC的博客\n&amp;quot;;
			Sleep(1500);
		}
		else if(!beta&amp;amp;&amp;amp;ch==&#39;6&#39;){
			system(&amp;quot;cls&amp;quot;);
			g=200;
			jkl=50;
			e1=8000;
			o1=5000;
			o1_max=5000;
			break;
		}
		else cout&amp;lt;&amp;lt;&amp;quot;不要乱输\n&amp;quot;,Sleep(1500);
	}
	system(&amp;quot;cls&amp;quot;);
	if(ssss!=&amp;quot;test&amp;quot;){
		cout&amp;lt;&amp;lt;&amp;quot;加载中...&amp;quot;;
		cout&amp;lt;&amp;lt;endl;
		srand(time(0));
		xx=rand()%int(rand?12:11);
		switch(xx){
			case 0:cout&amp;lt;&amp;lt;&amp;quot;高射炮不仅可以打飞机，把它压下来也可以打地面敌人！&amp;quot;;break;
			case 1:cout&amp;lt;&amp;lt;&amp;quot;迫击炮不仅可以打小兵，还能打敌方基地！&amp;quot;;break;
			case 2:cout&amp;lt;&amp;lt;&amp;quot;小兵打敌方基地的伤害十分可观。&amp;quot;;break;
			case 3:cout&amp;lt;&amp;lt;&amp;quot;导弹可以直接打对方的基地！&amp;quot;;break;
			case 4:cout&amp;lt;&amp;lt;&amp;quot;千万别让小兵接近你的基地，你的建筑十分危险！&amp;quot;;break;
			case 5:cout&amp;lt;&amp;lt;&amp;quot;激光炮可以攻击小兵、坦克、飞机或直接进攻敌方，十分强大！&amp;quot;;break;
			case 6:cout&amp;lt;&amp;lt;&amp;quot;护盾可以抵挡敌方的一次远程进攻哦！&amp;quot;;break;
			case 7:cout&amp;lt;&amp;lt;&amp;quot;克隆法术可以将小兵数量变成原来的两倍，在关键时刻能起到意想不到的作用&amp;quot;;break;
			case 8:cout&amp;lt;&amp;lt;&amp;quot;岩石地雷可以在五回合后炸死敌方所有小兵哦！&amp;quot;;break;
			case 9:cout&amp;lt;&amp;lt;&amp;quot;晶坷垃是一种新型货币，不可与金币互换。&amp;quot;;break;
			case 10:cout&amp;lt;&amp;lt;&amp;quot;头铁少年破盾，钻地少年清兵。但需要耗费晶坷垃，且没有动静。&amp;quot;;break;
			case 11:cout&amp;lt;&amp;lt;&amp;quot;歼击机攻击力极高，无法被防御塔击毁，需要谨慎防备。&amp;quot;;break;
		}
		cout&amp;lt;&amp;lt;&#39;\n&#39;;
		for(i=0;i&amp;lt;=12;i++) cout&amp;lt;&amp;lt;&#39;&amp;lt;&#39;,Sleep(100);
		Beep(1500,200);
		for(i=0;i&amp;lt;=12;i++) cout&amp;lt;&amp;lt;&#39;&amp;lt;&#39;,Sleep(100);
		Beep(1500,200);
		for(i=0;i&amp;lt;=12;i++) cout&amp;lt;&amp;lt;&#39;&amp;lt;&#39;,Sleep(100);
		Beep(1500,200);
		for(i=0;i&amp;lt;=14;i++) cout&amp;lt;&amp;lt;&#39;&amp;lt;&#39;,Sleep(100);
		Beep(2000,1000);
		cout&amp;lt;&amp;lt;&amp;quot; 100%&amp;quot;;
		Sleep(1500);
		system(&amp;quot;cls&amp;quot;);
	}else
	{
		cout&amp;lt;&amp;lt;&amp;quot;ji guang pao (ji fang):&amp;quot;;
		cin&amp;gt;&amp;gt;jg;
		cout&amp;lt;&amp;lt;&amp;quot;di fang gong ji li:&amp;quot;;
		cin&amp;gt;&amp;gt;e;
	}
	//system(&amp;quot;taskkill -f -im f_bgm.exe&amp;quot;);
	//system(&amp;quot;start bgm.exe&amp;quot;);
	system(&amp;quot;cls&amp;quot;);
	while(o1&amp;gt;0&amp;amp;&amp;amp;e1&amp;gt;0&amp;amp;&amp;amp;(sssss==&amp;quot;16391639&amp;quot;||ch==&#39;3&#39;||ch==&#39;2&#39;||g&amp;lt;=100000&amp;amp;&amp;amp;o1&amp;lt;=300000)){
		int ttt=o2;
		int fff=e2;
		o1-=e;
		int last_hp=o1;
		int last_hpe=e1;
		jkl++;
		jkl+=jkl_kc;
		water++;
		xs(ch);
		d=&#39; &#39;;
		srand(time(NULL));
		for(i=1;i&amp;lt;=1+int(beta);i++){
			l=rand()%30+1;
			if(zx!=0){
				zx--;
				l=12;
			}
			if(l&amp;gt;=0&amp;amp;&amp;amp;l&amp;lt;=1){
				sl=rand()%20+1;
				cout&amp;lt;&amp;lt;sl&amp;lt;&amp;lt;&amp;quot;个小兵出现了\n&amp;quot;;
				e2+=sl;
			}
			if(l&amp;gt;=2&amp;amp;&amp;amp;l&amp;lt;=3){
				if(hd==0){
					o1-=100;
					cout&amp;lt;&amp;lt;&amp;quot;一颗导弹在空中画出了一道完美的弧线\n&amp;quot;;
				}
				else{
					hd--;
					cout&amp;lt;&amp;lt;&amp;quot;一颗导弹炸毁了一层护盾\n&amp;quot;;
				}
			}
			if(l&amp;gt;=4&amp;amp;&amp;amp;l&amp;lt;=5){
				if(o2==0)
					if(tk!=0){
						cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，炸毁一辆坦克\n&amp;quot;;
						tk--;
					}
					else if(hd!=0){
						cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，炸毁了一层护盾\n&amp;quot;;
						hd--;
					}
					else{
						cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，向你方飞来\n&amp;quot;;
						o1-=80;
					}
				else{
					o2-=40;
					if(o2&amp;lt;0) o2=0;
					cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，炸死一批小兵\n&amp;quot;;
				}
			}
			if(l&amp;gt;=6&amp;amp;&amp;amp;l&amp;lt;=7){
				cout&amp;lt;&amp;lt;&amp;quot;一块巨石忽忽悠悠地飞来\n&amp;quot;;
				o2-=35;
				if(o2&amp;lt;0) o2=0;
			}
			if(l&amp;gt;=8&amp;amp;&amp;amp;l&amp;lt;=9){
				cout&amp;lt;&amp;lt;&amp;quot;一颗狙击枪子弹射来，&amp;quot;;
				if(pj!=0){
					cout&amp;lt;&amp;lt;&amp;quot;一门迫击炮炸了\n&amp;quot;;
					pj--;
				}
				else if(jg!=0){
					cout&amp;lt;&amp;lt;&amp;quot;一门激光炮炸了\n&amp;quot;;
					jg--;
				}
				else if(ts!=0){
					cout&amp;lt;&amp;lt;&amp;quot;一门投石机炸了\n&amp;quot;;
					ts--;
				}
				else if(bt!=0){
					cout&amp;lt;&amp;lt;&amp;quot;一座哨兵塔炸了\n&amp;quot;;
					bt--;
				}
				else if(hd!=0){
					cout&amp;lt;&amp;lt;&amp;quot;一层护盾炸了\n&amp;quot;;
					hd--;
				}
				else{
					cout&amp;lt;&amp;lt;&amp;quot;扣血150点\n&amp;quot;;
					o1-=150;
				}
			}
			if(l&amp;gt;=10&amp;amp;&amp;amp;l&amp;lt;=10){
				srand(time(NULL));
				sl=rand()%3+1;
				if(sl==3) sl=2;
				else sl=1;
				cout&amp;lt;&amp;lt;sl&amp;lt;&amp;lt;&amp;quot;辆坦克轰然出现\n&amp;quot;;
				tke+=sl;
			}
			if(l&amp;gt;=11&amp;amp;&amp;amp;l&amp;lt;=11){
				if(beta){
					cout&amp;lt;&amp;lt;&amp;quot;咻！一架歼击机穿过云层\n&amp;quot;;
					jjje++;
				}else cout&amp;lt;&amp;lt;&amp;quot;这轮什么也没出现\n&amp;quot;;
			}
			if(l&amp;gt;=13&amp;amp;&amp;amp;l&amp;lt;=13){
				cout&amp;lt;&amp;lt;&amp;quot;敌方建造了一个护盾\n&amp;quot;;
				hde++;
			}
			if(l&amp;gt;=14&amp;amp;&amp;amp;l&amp;lt;=15){
				if(fj!=0){
					cout&amp;lt;&amp;lt;&amp;quot;高射炮向天空扫去，一架飞机掉了下来\n&amp;quot;;
					fj--;
				}
				else{
					if(tk!=0){
						cout&amp;lt;&amp;lt;&amp;quot;高射炮向地面扫去，炸毁一辆坦克\n&amp;quot;;
						tk--;
					}
					else{
						if(o2!=0){
							cout&amp;lt;&amp;lt;&amp;quot;高射炮向地面扫去，炸死一个小兵\n&amp;quot;;
							o2--;
						}
						else cout&amp;lt;&amp;lt;&amp;quot;高射炮没有目标\n&amp;quot;;
					}
				}
			}
			if(l&amp;gt;=16&amp;amp;&amp;amp;l&amp;lt;=16){
				cout&amp;lt;&amp;lt;&amp;quot;一架飞机出现了\n&amp;quot;;
				fje++;
			}
			if(l&amp;gt;=17&amp;amp;&amp;amp;l&amp;lt;=18){
				cout&amp;lt;&amp;lt;&amp;quot;瘟疫发生了\n&amp;quot;;
				o2/=2;
			}
			if(l&amp;gt;=19&amp;amp;&amp;amp;l&amp;lt;=19){
				if(fj&amp;gt;=2){
					cout&amp;lt;&amp;lt;&amp;quot;一束激光射向天空，两架飞机掉了下来\n&amp;quot;;
					fj-=2;
				}
				else{
					if(fj==1){
						cout&amp;lt;&amp;lt;&amp;quot;一束激光射向天空，一架飞机掉了下来\n&amp;quot;;
						fj--;
					}
					else if(tk!=0&amp;amp;&amp;amp;o2!=0){
						cout&amp;lt;&amp;lt;&amp;quot;一束激光平射而来，击毁了&amp;quot;&amp;lt;&amp;lt;min(3,tk)&amp;lt;&amp;lt;&amp;quot;辆坦克，炸死&amp;quot;&amp;lt;&amp;lt;min(20,o2)&amp;lt;&amp;lt;&amp;quot;个小兵\n&amp;quot;;
						tk-=min(3,tk);
						o2-=min(20,o2);
					}
					else{
						if(tk!=0){
							cout&amp;lt;&amp;lt;&amp;quot;一束激光平射而来，击毁了&amp;quot;&amp;lt;&amp;lt;min(3,tk)&amp;lt;&amp;lt;&amp;quot;辆坦克\n&amp;quot;;
							tk-=min(3,tk);
						}
						else{
							if(o2!=0){
								cout&amp;lt;&amp;lt;&amp;quot;一束激光平射而来，炸死&amp;quot;&amp;lt;&amp;lt;min(20,o2)&amp;lt;&amp;lt;&amp;quot;个小兵\n&amp;quot;;
								o2-=min(20,o2);
							}
							else if(hd!=0){
								cout&amp;lt;&amp;lt;&amp;quot;一束激光平射而来，一层护盾炸了\n&amp;quot;;
								hd--;
							}
							else{
								cout&amp;lt;&amp;lt;&amp;quot;一束激光向你方平射而来\n&amp;quot;;
								o1-=100;
							}
						}
					}
				}
			}
			if(l&amp;lt;=20&amp;amp;&amp;amp;l&amp;gt;=20){
				cout&amp;lt;&amp;lt;&amp;quot;对方使用了神秘的法术，小兵数量变成了两倍\n&amp;quot;;
				e2*=2;
			}
			if(l&amp;lt;=21&amp;amp;&amp;amp;l&amp;gt;=21){
				cout&amp;lt;&amp;lt;&amp;quot;这轮什么也没出现\n&amp;quot;;
				jde++;
			}
			if(l&amp;gt;=12&amp;amp;&amp;amp;l&amp;lt;=12||l&amp;gt;=22&amp;amp;&amp;amp;l&amp;lt;=23||l&amp;gt;=28&amp;amp;&amp;amp;l&amp;lt;=30){
				cout&amp;lt;&amp;lt;&amp;quot;这轮什么也没出现\n&amp;quot;;
			}
			if(l&amp;gt;=24&amp;amp;&amp;amp;l&amp;lt;=25){
				cout&amp;lt;&amp;lt;&amp;quot;敌方建造了一个屏障\n&amp;quot;;
				pze++;
			}
			if(l&amp;gt;=26&amp;amp;&amp;amp;l&amp;lt;=26){
				cout&amp;lt;&amp;lt;&amp;quot;敌方建造了一个量子屏障\n&amp;quot;;
				lzpze++;
			}
			if(l&amp;gt;=27&amp;amp;&amp;amp;l&amp;lt;=27){
				cout&amp;lt;&amp;lt;&amp;quot;这轮什么也没出现\n&amp;quot;;
				dle++;
			}
			if(i==1) Sleep(2000);
		}
		dd=rand()%(beta?40:30)+1+jk*5;
		cout&amp;lt;&amp;lt;&amp;quot;你得到了&amp;quot;&amp;lt;&amp;lt;dd&amp;lt;&amp;lt;&amp;quot;个金币\n&amp;quot;;
		g+=dd;
		Sleep(2000);
		system(&amp;quot;cls&amp;quot;);
		while(d!=&#39;0&#39;){
			xs(ch);
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;1   派出小兵 3$/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             2   导弹 50$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;3   迫击炮 120$/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             4   投石机 100$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;5   坦克 60$/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             6   哨兵塔 100$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;7   高射炮 120$/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             8   飞机 80$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;9   瘟疫 50$/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             a   激光炮 180$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;b   护盾 80$/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             c   克隆法术 80$/1&amp;quot;;
			if(ch==&#39;3&#39;) cout&amp;lt;&amp;lt;&amp;quot;禁用\n&amp;quot;;
			else cout&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;d   金矿开采机 50$/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             e   间谍 80$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;f   诈降书 150$/1&amp;quot;;
			if(zx!=0) cout&amp;lt;&amp;lt;&amp;quot;禁用&amp;quot;;
			else cout&amp;lt;&amp;lt;&amp;quot;&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             g   屏障 2$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;h   量子屏障 10$/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             i   岩石地雷 50$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;j   晶坷垃开采器 5G/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;            k   头铁少年 5G/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;l   钻地少年 5G/1&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;             m   回血药水(回250) 10G+20$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;n   回血器(一次回50) 30G+60$/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			if(beta) cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;o   歼击机 120$+25G/1&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;p   打怪(实在不行去刷)&amp;quot;&amp;lt;&amp;lt;endl;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;q   查看注释&amp;quot;&amp;lt;&amp;lt;endl;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;r   开宝箱&amp;quot;&amp;lt;&amp;lt;endl;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;s   查看成就&amp;quot;&amp;lt;&amp;lt;endl;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;t   查看如何获得成就&amp;quot;&amp;lt;&amp;lt;endl;
			cout&amp;lt;&amp;lt;left&amp;lt;&amp;lt;setw(20)&amp;lt;&amp;lt;&amp;quot;u   抽奖&amp;quot;&amp;lt;&amp;lt;endl;
			if(beta) cout&amp;lt;&amp;lt;&amp;quot;*   升级主塔 100$+20G/1\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;\\   关闭\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;#   礼包码(hehe为官方礼包码)\n&amp;quot;;
			cout&amp;lt;&amp;lt;&amp;quot;0   继续&amp;quot;;
			d=getch();
			if(d==&#39;u&#39;){
				cj();
			}
			if(d==&#39;t&#39;){
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;买到终极宝箱（终极奥义）\n&amp;quot;);
				printf(&amp;quot;买宝箱20次  （奉献精神）\n&amp;quot;);
				printf(&amp;quot;杀死20个怪  （怪物猎人）\n&amp;quot;);
				printf(&amp;quot;买回血器5个 （回血大师）\n&amp;quot;);
				printf(&amp;quot;打死十级怪物（打怪大师）\n&amp;quot;);
				Sleep(5000);
			}
			if(d==&#39;s&#39;){
				system(&amp;quot;cls&amp;quot;);
				if(zjay) printf(&amp;quot;终极奥义\n&amp;quot;);
				if(fxjs) printf(&amp;quot;奉献精神\n&amp;quot;);
				if(gwlr) printf(&amp;quot;怪物猎人\n&amp;quot;);
				if(hxds) printf(&amp;quot;回血大师\n&amp;quot;);
				if(dgds) printf(&amp;quot;打怪大师\n&amp;quot;);
				Sleep(5000);
			}
			if(d==&#39;r&#39;){
				kaibx();
			}
			if(d==&#39;q&#39;){
				system(&amp;quot;cls&amp;quot;);
				printf(&amp;quot;因打怪，宝箱模板没有时间了，所以做得简陋一点\n&amp;quot;);
				printf(&amp;quot;下个版本升级的打怪\n&amp;quot;);
				Sleep(5000);
			}
			if(d==&#39;p&#39;){
				bdaguai();
			}
			if(d==&#39;#&#39;){
				system(&amp;quot;cls&amp;quot;);
				cout&amp;lt;&amp;lt;&amp;quot;请输入礼包码形如 *** 及你名字的缩写的小写形式\n&amp;quot;;
				cout&amp;lt;&amp;lt;&amp;quot;请输入:&amp;quot;;
				string str;
				cin&amp;gt;&amp;gt;str;
				if(str==ssss)
				  g+=100,jkl+=100,e1+=100;
				cout&amp;lt;&amp;lt;&amp;quot;正在处理...&amp;quot;;
				Sleep(1500);
				system(&amp;quot;cls&amp;quot;);
				continue;
			}
			if(d==&#39;\\&#39;){
				system(&amp;quot;cls&amp;quot;);
				return;
			}
			if(beta&amp;amp;&amp;amp;d==&#39;*&#39;){
				if(g&amp;gt;=100&amp;amp;&amp;amp;jkl&amp;gt;=20){
					g-=100;
					jkl-=20;
					Lv++;
					o1_max+=500;
					o1+=500;
					lzpz+=10;
				}
			}
			if(d==&#39;1&#39;){
				system(&amp;quot;cls&amp;quot;);
				xs(ch);
				cout&amp;lt;&amp;lt;&amp;quot;数量:&amp;quot;;
				cin&amp;gt;&amp;gt;s;
				while(s*3&amp;gt;g){
					system(&amp;quot;cls&amp;quot;);
					xs(ch);
					cout&amp;lt;&amp;lt;&amp;quot;数量:&amp;quot;;
					cin&amp;gt;&amp;gt;s;
				}
				o2+=s;
				g-=s*3;
				system(&amp;quot;cls&amp;quot;);
			}
			if(d==&#39;2&#39;){
				if(g&amp;gt;=50){
					g-=50;
					if(hde!=0){
						e1-=100;
					}
					else{
						hde--;
					}
				}
			}
			if(d==&#39;3&#39;){
				if(g&amp;gt;=120){
					g-=120;
					pj++;
				}
			}
			if(d==&#39;4&#39;){
				if(g&amp;gt;=100){
					g-=100;
					ts++;
				}
			}
			if(d==&#39;5&#39;){
				if(g&amp;gt;=60){
					g-=60;
					tk++;
				}
			}
			if(d==&#39;6&#39;){
				if(g&amp;gt;=100){
					g-=100;
					bt++;
				}
			}
			if(d==&#39;7&#39;){
				if(g&amp;gt;=120){
					g-=120;
					gs++;
				}
			}
			if(d==&#39;8&#39;){
				if(g&amp;gt;=80){
					g-=80;
					fj++;
				}
			}
			if(d==&#39;9&#39;){
				if(g&amp;gt;=50){
					g-=50;
					e2/=2;
				}
			}
			if(d==&#39;a&#39;){
				if(g&amp;gt;=180){
					g-=180;
					jg++;
				}
			}
			if(d==&#39;b&#39;){
				if(g&amp;gt;=80){
					g-=80;
					hd++;
				}
			}
			if(d==&#39;c&#39;){
				if(g&amp;gt;=80&amp;amp;&amp;amp;ch!=&#39;3&#39;){
					g-=80;
					system(&amp;quot;cls&amp;quot;);
					cout&amp;lt;&amp;lt;&amp;quot;一抹神秘的光辉映在天空中，小兵变成了原来的两倍\n&amp;quot;;
					Sleep(2500);
					o2*=2;
				}
			}
			if(d==&#39;d&#39;){
				if(g&amp;gt;=50){
					g-=50;
					jk++;
				}
			}
			if(d==&#39;e&#39;){
				if(g&amp;gt;=80){
					g-=80;
					jd++;
				}
			}
			if(d==&#39;f&#39;){
				if(g&amp;gt;=150&amp;amp;&amp;amp;zx==0){
					g-=150;
					zx+=5;
				}
			}
			if(d==&#39;g&#39;){
				system(&amp;quot;cls&amp;quot;);
				xs(ch);
				cout&amp;lt;&amp;lt;&amp;quot;数量:&amp;quot;;
				cin&amp;gt;&amp;gt;s;
				while(s*2&amp;gt;g){
					system(&amp;quot;cls&amp;quot;);
					xs(ch);
					cout&amp;lt;&amp;lt;&amp;quot;数量:&amp;quot;;
					cin&amp;gt;&amp;gt;s;
				}
				pz+=s;
				g-=s*2;
				system(&amp;quot;cls&amp;quot;);
			}
			if(d==&#39;h&#39;){
				system(&amp;quot;cls&amp;quot;);
				xs(ch);
				cout&amp;lt;&amp;lt;&amp;quot;数量:&amp;quot;;
				cin&amp;gt;&amp;gt;s;
				while(s*10&amp;gt;g){
					system(&amp;quot;cls&amp;quot;);
					xs(ch);
					cout&amp;lt;&amp;lt;&amp;quot;数量:&amp;quot;;
					cin&amp;gt;&amp;gt;s;
				}
				lzpz+=s;
				g-=s*10;
				system(&amp;quot;cls&amp;quot;);
			}
			if(d==&#39;i&#39;){
				if(g&amp;gt;=50){
					g-=50;
					dl+=5;
				}
			}
			if(d==&#39;j&#39;){
				if(jkl&amp;gt;=5){
					jkl-=5;
					jkl_kc++;
				}
			}
			if(d==&#39;k&#39;){
				if(jkl&amp;gt;=5){
					jkl-=5;
					tt++;
				}
			}
			if(d==&#39;l&#39;){
				if(jkl&amp;gt;=5){
					jkl-=5;
					zd++;
				}
			}
			if(d==&#39;m&#39;){
				if(jkl&amp;gt;=10&amp;amp;&amp;amp;g&amp;gt;=20){
					jkl-=10;
					g-=20;
					o1=min(o1_max,o1+250);
				}
			}
			if(d==&#39;n&#39;){
				if(jkl&amp;gt;=30&amp;amp;&amp;amp;g&amp;gt;=60){
					jkl-=30;
					g-=60;
					reblood++;
					hxcs++;
					if(hxcs&amp;gt;=5&amp;amp;&amp;amp;hxds!=1){
						hxds=1;
						system(&amp;quot;cls&amp;quot;);
						printf(&amp;quot;恭喜你取得了回血大师的成就！！！\n&amp;quot;);
						Sleep(5000);
						printf(&amp;quot;奖励10晶坷垃,100金币&amp;quot;);
						g+=100;
						jkl+=10;
						Sleep(5000);
					}
				}
			}
			if(d==&#39;o&#39;){
				if(g&amp;gt;=120&amp;amp;&amp;amp;jkl&amp;gt;=25){
					g-=120;
					jkl-=25;
					jjj++;
				}
			}
			system(&amp;quot;cls&amp;quot;);
		}
		if(dl!=0){
			if(dl%5!=0)
			  dl-=(dl/5+1);else
			  dl-=dl/5;
			if(dl%5==0){
				cout&amp;lt;&amp;lt;&amp;quot;一声惊天巨响，敌方小兵化为骨灰\n&amp;quot;;
				e2=0;
			}
		}
		if(dle!=0){
			if(dle%5!=0)
			  dle-=(dle/5+1);else
			  dle-=dle/5;
			if(dle%5==0){
				cout&amp;lt;&amp;lt;&amp;quot;一声惊天巨响，我方小兵化为骨灰\n&amp;quot;;
				o2=0;
			}
		}
		if(jd!=0){
			if(e2!=0){
				cout&amp;lt;&amp;lt;&amp;quot;我方间谍使敌方&amp;quot;&amp;lt;&amp;lt;min(jd,e2)&amp;lt;&amp;lt;&amp;quot;个小兵叛变了\n&amp;quot;;
				e2-=min(jd,e2);
				o2+=min(jd,e2);
			}
			else{
				cout&amp;lt;&amp;lt;&amp;quot;我方间谍被发现！\n&amp;quot;;
				jd=0;
			}
		}
		if(jde!=0){
			if(o2!=0){
				o2-=min(jde,o2);
				e2+=min(jde,o2);
			}
			else{
				cout&amp;lt;&amp;lt;&amp;quot;敌方间谍被发现！\n&amp;quot;;
				jde=0;
			}
		}
		if(tt!=0){
			if(hde!=0){
				hde-=min(min(tt,hde),jkl);
				jkl-=min(min(tt,hde),jkl);
			}
			if(hde&amp;lt;=0) hde=0;
		}
		if(zd!=0){
			if(e2!=0){
				e2-=min(min(e2/10,zd),jkl);
				jkl-=min(min(e2/10,zd),jkl);
			}
			if(e2&amp;lt;=0) e2=0;
		}
		for(i=1;i&amp;lt;=pj;i++)
			if(e2==0)
				if(tke!=0){
					cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，炸毁一辆坦克\n&amp;quot;;
					tke--;
				}
				else{
					if(hde!=0){
						cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，击毁一层护盾\n&amp;quot;;
						hde--;
					}
					else{
						cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，向敌方飞去\n&amp;quot;;
						e1-=80;
					}
				}
			else{
				if(e2&amp;gt;=40){
					g+=80;
					e2-=40;
				}
				else{
					g+=e2*2;
					e2=0;
				}
				if(e2&amp;lt;0) e2=0;
				cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，炸死一批小兵\n&amp;quot;;
			}
		for(i=1;i&amp;lt;=ts;i++){
			if(e2&amp;gt;=35){
				e2-=35;
				g+=70;
			}
			else{
				g+=e2*2;
				e2=0;
			}
			cout&amp;lt;&amp;lt;&amp;quot;一块巨石忽忽悠悠地飞去\n&amp;quot;;
		}
		for(i=1;i&amp;lt;=bt;i++){
			cout&amp;lt;&amp;lt;&amp;quot;5个小兵慢悠悠地从哨兵塔里走出来\n&amp;quot;;
			o2+=5;
		}
		for(i=1;i&amp;lt;=gs;i++){
			if(fje!=0){
				cout&amp;lt;&amp;lt;&amp;quot;高射炮向天空扫去，一架飞机掉了下来\n&amp;quot;;
				fje--;
			}
			else{
				if(tke!=0){
					cout&amp;lt;&amp;lt;&amp;quot;高射炮向地面扫去，炸毁一辆坦克\n&amp;quot;;
					tke--;
				}
				else{
					if(e2!=0){
						cout&amp;lt;&amp;lt;&amp;quot;高射炮向地面扫去，炸死一个小兵\n&amp;quot;;
						e2--;
					}
					else cout&amp;lt;&amp;lt;&amp;quot;高射炮没有目标\n&amp;quot;;
				}
			}
		}
		for(i=1;i&amp;lt;=jg;i++)
			if(fje&amp;gt;=2){
				cout&amp;lt;&amp;lt;&amp;quot;一束激光射向天空，两架飞机掉了下来\n&amp;quot;;
				fje-=2;
			}
			else{
				if(fje==1){
					cout&amp;lt;&amp;lt;&amp;quot;一束激光射向天空，一架飞机掉了下来\n&amp;quot;;
					fje--;
				}
				else if(tke!=0&amp;amp;&amp;amp;e2!=0){
					cout&amp;lt;&amp;lt;&amp;quot;一束激光平射出去，击毁了&amp;quot;&amp;lt;&amp;lt;min(3,tke)&amp;lt;&amp;lt;&amp;quot;辆坦克，炸死&amp;quot;&amp;lt;&amp;lt;min(15,e2)&amp;lt;&amp;lt;&amp;quot;个小兵\n&amp;quot;;
					tke-=min(3,tke);
					e2-=min(15,e2);
				}
				else{
					if(tke!=0){
						cout&amp;lt;&amp;lt;&amp;quot;一束激光平射出去，击毁了&amp;quot;&amp;lt;&amp;lt;min(3,tke)&amp;lt;&amp;lt;&amp;quot;辆坦克\n&amp;quot;;
						tke-=min(3,tke);
					}
					else{
						if(e2!=0){
							cout&amp;lt;&amp;lt;&amp;quot;一束激光平射出去，炸死&amp;quot;&amp;lt;&amp;lt;min(15,e2)&amp;lt;&amp;lt;&amp;quot;个小兵\n&amp;quot;;
							e2-=min(15,e2);
						}
						else{
							if(hde!=0){
								cout&amp;lt;&amp;lt;&amp;quot;一束激光平射出去，击毁一层护盾\n&amp;quot;;
								hde--;
							}
							else{
								cout&amp;lt;&amp;lt;&amp;quot;一束激光向敌方平射出去\n&amp;quot;;
								e1-=150;
							}

						}
					}
				}
			}
		if(fj!=0&amp;amp;&amp;amp;fje!=0){
			fk=fj&amp;lt;fje?fj:fje;
			fj-=fk;fje-=fk;
			cout&amp;lt;&amp;lt;&amp;quot;双方都有&amp;quot;&amp;lt;&amp;lt;fk&amp;lt;&amp;lt;&amp;quot;架飞机从空中落下来了\n&amp;quot;;
		}
		for(i=1;i&amp;lt;=fj;i++){
			if(hde!=0){
				cout&amp;lt;&amp;lt;&amp;quot;我方飞机击毁一层护盾\n&amp;quot;;
				hde--;
			}
			else{
				cout&amp;lt;&amp;lt;&amp;quot;我方飞机俯冲轰炸！\n&amp;quot;;
				e1-=150;
			}
		}
		for(i=1;i&amp;lt;=fje;i++){
			if(hd!=0){
				cout&amp;lt;&amp;lt;&amp;quot;敌方飞机击毁我方一层护盾\n&amp;quot;;
				hd--;
			}
			else{
				cout&amp;lt;&amp;lt;&amp;quot;敌方飞机俯冲轰炸！\n&amp;quot;;
				o1-=150;
			}
		}
		if(jjj!=0&amp;amp;&amp;amp;jjje!=0){
			fk=jjj&amp;lt;jjje?jjj:jjje;
			jjj-=fk;jjje-=fk;
			cout&amp;lt;&amp;lt;&amp;quot;双方都有&amp;quot;&amp;lt;&amp;lt;fk&amp;lt;&amp;lt;&amp;quot;架歼击机从空中落下来了\n&amp;quot;;
		}
		for(i=1;i&amp;lt;=jjj;i++){
			if(hde!=0){
				cout&amp;lt;&amp;lt;&amp;quot;我方歼击机击毁一层护盾\n&amp;quot;;
				hde--;
			}
			else{
				cout&amp;lt;&amp;lt;&amp;quot;我方歼击机俯冲轰炸！\n&amp;quot;;
				e1-=200;
			}
		}
		for(i=1;i&amp;lt;=jjje;i++){
			if(hd!=0){
				cout&amp;lt;&amp;lt;&amp;quot;敌方歼击机击毁我方一层护盾\n&amp;quot;;
				hd--;
			}
			else{
				cout&amp;lt;&amp;lt;&amp;quot;敌方歼击机俯冲轰炸！\n&amp;quot;;
				o1-=200;
			}
		}
		if(tk!=0&amp;amp;&amp;amp;tke!=0){
			tkk=tk&amp;lt;tke?tk:tke;
			cout&amp;lt;&amp;lt;&amp;quot;坦克开炮了，双方都有&amp;quot;&amp;lt;&amp;lt;tkk&amp;lt;&amp;lt;&amp;quot;门坦克损毁了\n&amp;quot;;
			tk-=tkk;tke-=tkk;
		}
		if(o2!=0&amp;amp;&amp;amp;tke*20&amp;gt;o2){
			cout&amp;lt;&amp;lt;&amp;quot;坦克开炮了，&amp;quot;&amp;lt;&amp;lt;o2&amp;lt;&amp;lt;&amp;quot;个小兵死去了\n&amp;quot;;
			if(o2/20!=0)
				cout&amp;lt;&amp;lt;o2/20&amp;lt;&amp;lt;&amp;quot;门坦克损毁了\n&amp;quot;;
			o2=0;tke-=o2/20;
		}
		if(tke!=0&amp;amp;&amp;amp;o2&amp;gt;=tke*20){
			cout&amp;lt;&amp;lt;&amp;quot;坦克开炮了，&amp;quot;&amp;lt;&amp;lt;tke*20&amp;lt;&amp;lt;&amp;quot;个小兵死去了\n&amp;quot;;
			g+=tke*60;
			cout&amp;lt;&amp;lt;tke&amp;lt;&amp;lt;&amp;quot;门坦克损毁了\n&amp;quot;;
			o2-=tke*20;tke=0;
		}
		if(o2!=0&amp;amp;&amp;amp;e2!=0)
			cout&amp;lt;&amp;lt;&amp;quot;有小兵倒下去了\n&amp;quot;;
		else cout&amp;lt;&amp;lt;&amp;quot;没有小兵倒下\n&amp;quot;;
		if(e2!=0&amp;amp;&amp;amp;tk*20&amp;gt;e2){
			cout&amp;lt;&amp;lt;&amp;quot;坦克开炮了，&amp;quot;&amp;lt;&amp;lt;e2&amp;lt;&amp;lt;&amp;quot;个小兵死去了\n&amp;quot;;
			g+=tk*60;
			if(e2/20!=0)
				cout&amp;lt;&amp;lt;e2/20&amp;lt;&amp;lt;&amp;quot;门坦克损毁了\n&amp;quot;;
			e2=0;tk-=e2/20;
		}
		if(tk!=0&amp;amp;&amp;amp;e2&amp;gt;=tk*20){
			cout&amp;lt;&amp;lt;&amp;quot;坦克开炮了，&amp;quot;&amp;lt;&amp;lt;tk*20&amp;lt;&amp;lt;&amp;quot;个小兵死去了\n&amp;quot;;
			g+=tk*60;
			cout&amp;lt;&amp;lt;tk&amp;lt;&amp;lt;&amp;quot;门坦克损毁了\n&amp;quot;;
			e2-=tk*20;tk=0;
		}
		if(ttt-o2&amp;gt;50){
			o2-=(ttt-o2)/10;
			cout&amp;lt;&amp;lt;&amp;quot;我方有&amp;quot;&amp;lt;&amp;lt;(ttt-o2)/10&amp;lt;&amp;lt;&amp;quot;个小兵逃走了&amp;quot;;
		}
		if(fff-e2&amp;gt;50){
			e2-=(fff-e2)/10;
			cout&amp;lt;&amp;lt;&amp;quot;敌方有&amp;quot;&amp;lt;&amp;lt;(fff-e2)/10&amp;lt;&amp;lt;&amp;quot;个小兵逃走了&amp;quot;;
		}
		if(o2&amp;gt;e2){
			g+=e2*2;
			o2-=e2;
			e2=0;
		}
		else{
			g+=o2*2;
			e2-=o2;
			o2=0;
		}
		if(o2!=0){
			e1-=o2*5;
			cout&amp;lt;&amp;lt;&amp;quot;我方小兵围殴敌方，扣血&amp;quot;&amp;lt;&amp;lt;o2*5&amp;lt;&amp;lt;&amp;quot;点\n&amp;quot;;
		}
		if(tk!=0){
			e1-=tk*20;
			cout&amp;lt;&amp;lt;&amp;quot;我方坦克围殴敌方，扣血&amp;quot;&amp;lt;&amp;lt;tk*20&amp;lt;&amp;lt;&amp;quot;点\n&amp;quot;;
		}
		if(e2!=0){
			k=e2;
			if(pj*30&amp;gt;k){
				if(k/30!=0)
					cout&amp;lt;&amp;lt;k/30&amp;lt;&amp;lt;&amp;quot;门迫击炮损坏了\n&amp;quot;;
				pj-=k/30;
			}
			else{
				if(pj!=0)
					cout&amp;lt;&amp;lt;pj&amp;lt;&amp;lt;&amp;quot;门迫击炮损坏了\n&amp;quot;;
				k-=pj*30;pj=0;
				if(ts*25&amp;gt;k){
					if(k/25!=0)
						cout&amp;lt;&amp;lt;k/25&amp;lt;&amp;lt;&amp;quot;门投石机损坏了\n&amp;quot;;
					ts-=k/25;
				}
				else{
					if(ts!=0)
						cout&amp;lt;&amp;lt;ts&amp;lt;&amp;lt;&amp;quot;门投石机损坏了\n&amp;quot;;
					k-=ts*25;ts=0;
					if(jg*35&amp;gt;k){
						if(k/35!=0)
							cout&amp;lt;&amp;lt;k/35&amp;lt;&amp;lt;&amp;quot;架激光炮损坏了\n&amp;quot;;
						jg-=k/35;
					}
					else{
						if(jg!=0)
							cout&amp;lt;&amp;lt;jg&amp;lt;&amp;lt;&amp;quot;架激光炮损坏了\n&amp;quot;;
						k-=jg*35;jg=0;
						if(bt*20&amp;gt;k){
							if(k/20!=0)
								cout&amp;lt;&amp;lt;k/20&amp;lt;&amp;lt;&amp;quot;座哨兵塔损坏了\n&amp;quot;;
							bt-=k/20;
						}
						else{
							if(bt!=0)
								cout&amp;lt;&amp;lt;bt&amp;lt;&amp;lt;&amp;quot;座哨兵塔损坏了\n&amp;quot;;
							k-=bt*20;bt=0;
							if(k!=0){
								cout&amp;lt;&amp;lt;&amp;quot;敌方小兵围殴我方，扣血&amp;quot;&amp;lt;&amp;lt;k*5&amp;lt;&amp;lt;&amp;quot;点\n&amp;quot;;
								o1-=k*5;
							}
						}
					}
				}
			}
		}
		for(i=1;i&amp;lt;=tke;i++){
			if(pj!=0){
				pj--;
				cout&amp;lt;&amp;lt;&amp;quot;1门迫击炮损坏了\n&amp;quot;;
			}
			else if(jg!=0){
				jg--;
				cout&amp;lt;&amp;lt;&amp;quot;1架激光炮损坏了\n&amp;quot;;
			}
			else if(ts!=0){
				ts--;
				cout&amp;lt;&amp;lt;&amp;quot;1门投石机损坏了\n&amp;quot;;
			}
			else if(bt!=0){
				bt--;
				cout&amp;lt;&amp;lt;&amp;quot;1座哨兵塔损坏了\n&amp;quot;;
			}
			else{
				o1-=(tke-i+1)*100;
				cout&amp;lt;&amp;lt;&amp;quot;敌方坦克围殴我方，扣血&amp;quot;&amp;lt;&amp;lt;(tke-i+1)*100&amp;lt;&amp;lt;&amp;quot;点\n&amp;quot;;
				i=tke;
			}
		}
		if(o1&amp;lt;last_hp) o1+=min(lzpz,last_hp-o1);
		if(o1&amp;lt;last_hp){
			o1+=min(pz,last_hp-o1);
			pz-=min(pz,last_hp-o1);
		}
		if(e1&amp;lt;last_hpe) e1+=min(lzpze,last_hpe-e1);
		if(e1&amp;lt;last_hpe){
			e1+=min(pze,last_hpe-e1);
			pze-=min(pze,last_hpe-e1);
		}
		cout&amp;lt;&amp;lt;&amp;quot;咕嘟嘟,+&amp;quot;&amp;lt;&amp;lt;reblood*50&amp;lt;&amp;lt;&amp;quot;血\n&amp;quot;;
		o1=min(o1_max,o1+reblood*50);
		Sleep(3000);
		system(&amp;quot;cls&amp;quot;);
		if(ch==&#39;3&#39;) ++iii;
	}
	if(g&amp;gt;10000||o1&amp;gt;10000) bg();
	if(o1&amp;lt;=0){
		if(e1&amp;gt;500&amp;amp;&amp;amp;e1&amp;lt;1500) cout&amp;lt;&amp;lt;&amp;quot;城池被攻破，人类的最后一道防线破碎，人类沦为了宇宙中的一片尘埃。\n&amp;quot;;
		if(e1&amp;gt;=1500) cout&amp;lt;&amp;lt;&amp;quot;你已经很努力了，但敌方太强，你无法抗衡\n人类不堪的淹没在了历史的长河中。\n&amp;quot;;
		if(e1&amp;lt;=500) cout&amp;lt;&amp;lt;&amp;quot;你的各个方面都很强，但在最后无法力挽狂澜，才使人类文明灭亡。\n&amp;quot;;
	}
	else{
		if(o1&amp;gt;500&amp;amp;&amp;amp;o1&amp;lt;1500) cout&amp;lt;&amp;lt;&amp;quot;你靠自己的顽强决心守住了城池，救回了人类文明。\n&amp;quot;;
		if(o1&amp;lt;=500) cout&amp;lt;&amp;lt;&amp;quot;你在最后的紧要关头击退了人类异种，挽救了人类文明。\n&amp;quot;;
		if(o1&amp;gt;=1500) cout&amp;lt;&amp;lt;&amp;quot;你以自己的高超指挥能力击退了人类异种，拯救了整个人类！！！\n\n&amp;quot;;
	}
	Sleep(3000);
	system(&amp;quot;cls&amp;quot;);
	if(ssss!=&amp;quot;16391639&amp;quot;){
		system(&amp;quot;cls&amp;quot;);
		cout&amp;lt;&amp;lt;&amp;quot;若有bug,加入需求及新想法,请发表\n&amp;quot;;
		cout&amp;lt;&amp;lt;&amp;quot;goodbye&amp;quot;&amp;lt;&amp;lt;endl;
		Sleep(2500);
		return;
	}
	//system(&amp;quot;taskkill -f -im bgm.exe&amp;quot;);
	//system(&amp;quot;cls&amp;quot;);
	//system(&amp;quot;start second.exe&amp;quot;);
	//Sleep(5000);
	//system(&amp;quot;start third.exe&amp;quot;);
	//system(&amp;quot;pause&amp;quot;);
	return;
}
void bg(){
	system(&amp;quot;cls&amp;quot;);
	cout&amp;lt;&amp;lt;&amp;quot;小朋友想走不正当途径是不好的\n&amp;quot;;
	Sleep(3000);
	xs(ch);
	for(i=1;i&amp;lt;=10000;i++)
		 cout&amp;lt;&amp;lt;&amp;quot;迫击炮轰然发射出一颗炮弹，向你方飞来\n&amp;quot;;
	cout&amp;lt;&amp;lt;&amp;quot;你死了！&amp;quot;;
}
int main(){
	//system(&amp;quot;start f_bgm.exe&amp;quot;);
	//system(&amp;quot;start first.exe&amp;quot;);
	//system(&amp;quot;cls&amp;quot;);
	std::srand(time(0));
	printf(&amp;quot;加载中...\n&amp;quot;);
	for(i=0;i&amp;lt;=12;i++) cout&amp;lt;&amp;lt;&#39;&amp;lt;&#39;,Sleep(100);
	Beep(1500,200);
	for(i=0;i&amp;lt;=12;i++) cout&amp;lt;&amp;lt;&#39;&amp;lt;&#39;,Sleep(100);
	Beep(1500,200);
	for(i=0;i&amp;lt;=12;i++) cout&amp;lt;&amp;lt;&#39;&amp;lt;&#39;,Sleep(100);
	Beep(1500,200);
	for(i=0;i&amp;lt;=14;i++) cout&amp;lt;&amp;lt;&#39;&amp;lt;&#39;,Sleep(100);
	Beep(2000,1000);
	cout&amp;lt;&amp;lt;&amp;quot; 100%&amp;quot;;
	Sleep(1500);
	system(&amp;quot;cls&amp;quot;);
	cout&amp;lt;&amp;lt;&amp;quot;黑_白(永远的CC) 段建泽出品\n&amp;quot;;
	cout&amp;lt;&amp;lt;&amp;quot;请输入姓名\n&amp;quot;;
	cout&amp;lt;&amp;lt;&amp;quot;格式为***，前后没有空格，全部为小写\n&amp;quot;;
	cin&amp;gt;&amp;gt;ssss;
	system(&amp;quot;cls&amp;quot;),aa(ssss);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">人类沦陷-史诗级巨作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/kuai-du-kuai-xie-shi-shi-me-zen-me-xie-ke-yi-yong-lai-qia-chang-ma/"" data-c="
          &lt;h1 id=&#34;part-0前言&#34;&gt;Part 0：前言&lt;/h1&gt;
&lt;p&gt;突发奇想，来介绍快读快写。&lt;/p&gt;
&lt;p&gt;希望大家喜欢！😉&lt;/p&gt;
&lt;h1 id=&#34;part-1快读快写是什么&#34;&gt;Part 1：快读快写是什么？&lt;/h1&gt;
&lt;p&gt;因为&lt;code&gt;getchar()&lt;/code&gt;和&lt;code&gt;putchar()&lt;/code&gt;很快，所以我们可以利用这个把输入输出的速度提到很快。&lt;/p&gt;
&lt;h1 id=&#34;part-2怎么写&#34;&gt;Part 2：怎么写？&lt;/h1&gt;
&lt;h2 id=&#34;part-21快读&#34;&gt;Part 2.1：快读&lt;/h2&gt;
&lt;h3 id=&#34;写法&#34;&gt;写法：&lt;/h3&gt;
&lt;p&gt;首先定义函数&lt;code&gt;int read()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;既然是读入整数，那么就要把多余的空格和负数考虑到：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f=1;
char ch=getchar();
while(ch&amp;lt;&#39;0&#39;||ch&amp;gt;&#39;9&#39;){
	if(ch==&#39;-&#39;)
	f=-1;
	ch=getchar();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后边输入边加在一个变量上：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int s=0;
while(ch&amp;gt;=&#39;0&#39;&amp;amp;&amp;amp;ch&amp;lt;=&#39;9&#39;){
	s=s*10+ch-&#39;0&#39;;
	ch=getchar();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里还不够快，把&lt;code&gt;s*10&lt;/code&gt;改成位运算：&lt;code&gt;(s&amp;lt;&amp;lt;1+s&amp;lt;&amp;lt;3)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后输出（别忘把负数的情况考虑上）：&lt;code&gt;return s*f&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int read(){
	int s=0,f=1;
	char ch=getchar();
	while(ch&amp;lt;&#39;0&#39;||ch&amp;gt;&#39;9&#39;){
		if(ch==&#39;-&#39;)
			f=-1;
		ch=getchar();
	}
	while(ch&amp;gt;=&#39;0&#39;&amp;amp;&amp;amp;ch&amp;lt;=&#39;9&#39;){
		s=(s&amp;lt;&amp;lt;1+s&amp;lt;&amp;lt;3)+ch-&#39;0&#39;;
		ch=getchar();
	}
	return s*f;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解析&#34;&gt;解析：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义函数和变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while()&lt;/code&gt;输入直到&lt;code&gt;-&lt;/code&gt;或数字，记录负数的情况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while()&lt;/code&gt;边输入边累加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt;返回值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;part-22快写&#34;&gt;Part 2.2：快写&lt;/h2&gt;
&lt;p&gt;递归写法，比较简单。&lt;/p&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void write(int x){
    if(x&amp;lt;0){
    	putchar(&#39;-&#39;);
		x=-x;
	}
    if(x&amp;gt;9) 
		write(x/10);
    putchar(x%10+&#39;0&#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;part3可以用来卡常吗&#34;&gt;Part3：可以用来卡常吗？&lt;/h1&gt;
&lt;p&gt;可以。&lt;/p&gt;
">快读快写是什么？怎么写？可以用来卡常吗？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/ru-he-yong-cwan-generalsio/"" data-c="
          &lt;p&gt;源自generals.io&lt;/p&gt;
&lt;p&gt;大洋彼岸的服务器体验极差！&lt;/p&gt;
&lt;p&gt;使用说明&lt;/p&gt;
&lt;p&gt;整合了零人、单人、双人版&lt;/p&gt;
&lt;h1 id=&#34;单人版通用规则&#34;&gt;单人版&amp;amp;&amp;amp;通用规则&lt;/h1&gt;
&lt;p&gt;图片：https://www.picb.cc/image/tAJbks和https://www.picb.cc/image/tAJ7Nj&lt;/p&gt;
&lt;p&gt;先输入0/1/2，代表游戏人数&lt;/p&gt;
&lt;p&gt;然后要输入一个随机数种子（更新：长度可以任意），相同种子（相同编译器？）生成相同地图&lt;/p&gt;
&lt;p&gt;地图：X为障碍，黑色背景的数为原有城市，红色为玩家的，蓝色为电脑的，城市和普通地面颜色不同&lt;/p&gt;
&lt;p&gt;数字表示：数大于99时只显示最高位和一个字母 （e代表100，k代表1000，w代表10000），数大于99999就显示&amp;quot;ju&amp;quot; （巨）&lt;/p&gt;
&lt;p&gt;在屏幕左下角可以看到光标所指的数的精确值（hp）&lt;/p&gt;
&lt;p&gt;光标是一个小于号&amp;quot;&amp;lt;&amp;quot;，用方向键控制光标&lt;/p&gt;
&lt;p&gt;按下w/s/a/d时，光标的左边那个数（前提是自己的）会随光标移动&lt;/p&gt;
&lt;p&gt;按下z，再按w/s/a/d，光标的左边那个数（前提是自己的）的一半会随光标移动&lt;/p&gt;
&lt;p&gt;无法移动的情况：遇到障碍/下一个位置上的数不是自己的，且&amp;gt;=自己的数-1&lt;/p&gt;
&lt;p&gt;时间以回合（count）为单位，在屏幕左下角&lt;/p&gt;
&lt;p&gt;移动光标不算回合，移动数字算，按到空格键视作放弃一回合&lt;/p&gt;
&lt;p&gt;城市每回合+2，其余被占领的地面每10回合+1&lt;/p&gt;
&lt;p&gt;屏幕左下角的&amp;quot;army&amp;quot;指一方数字和，&amp;quot;land&amp;quot;指一方占领的格子数&lt;/p&gt;
&lt;h1 id=&#34;零人版&#34;&gt;零人版&lt;/h1&gt;
&lt;p&gt;两个一样的bfs算法对打&lt;/p&gt;
&lt;p&gt;只要观战就可以啦&lt;/p&gt;
&lt;p&gt;可以按方向键移动光标，但不能移动任何数&lt;/p&gt;
&lt;p&gt;按下空格键进入下一回合&lt;/p&gt;
&lt;p&gt;如果想快点看到结果，按f键，之后无法移动光标&lt;/p&gt;
&lt;h1 id=&#34;双人版&#34;&gt;双人版&lt;/h1&gt;
&lt;p&gt;红方键盘：(z/x+) w/s/a/d，默认只移动光标，按z移一半&lt;br&gt;
数，按x移全部&lt;/p&gt;
&lt;p&gt;蓝方键盘：(n/m+) 方向键，默认只移动光标，按n移一半数，按m移全部&lt;/p&gt;
&lt;p&gt;任何一方按空格可以放弃一回合&lt;/p&gt;
&lt;p&gt;游戏时间会很漫长&lt;/p&gt;
&lt;p&gt;地图有概率出现“封城”，城市也可能分布不公平，换一个种&lt;br&gt;
子重启（继续碰运气）即可&lt;/p&gt;
&lt;p&gt;当一方操作结束，光标会移到地图的左上角或右下角，（希望）能方便操作&lt;/p&gt;
&lt;p&gt;结束条件：占领所有主塔（最开始的塔再【1】【1】或【n】【n】）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt; 
#include&amp;lt;cstdio&amp;gt; 
#include&amp;lt;fstream&amp;gt; 
#include&amp;lt;algorithm&amp;gt; 
#include&amp;lt;cmath&amp;gt; 
#include&amp;lt;deque&amp;gt; 
#include&amp;lt;vector&amp;gt; 
#include&amp;lt;queue&amp;gt; 
#include&amp;lt;string&amp;gt; 
#include&amp;lt;cstring&amp;gt; 
#include&amp;lt;map&amp;gt; 
#include&amp;lt;stack&amp;gt; 
#include&amp;lt;set&amp;gt; 
#include&amp;lt;windows.h&amp;gt;
#include&amp;lt;conio.h&amp;gt;
#include&amp;lt;ctime&amp;gt;
using namespace std;

const int cA=5;//red城市 
const int cB=3;//blue城市 
const int ca=4;//red地面 
const int cb=1;//blue地面 
const int cC=0;//black原有城市 
const int msize=16;//地图大小 
const int mount=16;//障碍数量 
const int grey=16;//城市数量 
const int pmain=2;//城市hp每回合增加量 
const int lcnt=10;//地面hp增加1所需回合 

char cMap[msize][msize];//大写字母表示城市，小写表示地面，Aa是红，Bb是蓝，C是白，X是障碍 
int hp[msize][msize];
int nCount,sx,sy;//回合累加，和光标的坐标 
bool bVis[msize][msize];//bfs
int dir[4][2]={1,0,-1,0,0,1,0,-1};//bfs

struct dRet//决策信息：位置为(x,y)的数移到(x+dx,y+dy) 
{
	int x;
	int y;
	int dx;
	int dy;
};

struct node//bfs 
{
	int x;
	int y;
	int step;
};

void vInit();//生成地图 
void vMove(int dx,int dy);//移动光标 
//以下5个函数，保证A==&#39;A&#39;||A==&#39;B&#39; 
void vMoveNum(int dx,int dy,char A);
void vMoveNum(int x,int y,int dx,int dy,char A);
void vDiv(int dx,int dy,char A);
void vDecide(char A);
dRet bfs(int x,int y,char A);
void vPlus();//每回合数值增加，计算army和land 
void vChange(int x,int y);//刷新屏幕上指定坐标的数 
void gotoxy(int x,int y);//移动输出的位置 
void color(int t,int b);//设置输出颜色，t为文字色，b为背景色 
void vMain0();
void vMain1();
void vMain2();
void vEnd();//判断游戏结束 

int main()
{
	int p; 
	cout&amp;lt;&amp;lt;&amp;quot;player:&amp;quot;&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;p;
	system(&amp;quot;cls&amp;quot;);
	if(p==0) vMain0();
	if(p==1) vMain1();
	if(p==2) vMain2();
	return 0;
}

void vMain0()
{
	int in;
	bool cur=true;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&amp;lt;&amp;lt;&amp;quot;count=&amp;quot;&amp;lt;&amp;lt;nCount&amp;lt;&amp;lt;endl;
		if(cur)
		{
			do
			{
				in=getch();
				if(in==224) 
				{
					in=getch();
					if(in==72) vMove(-1,0);
					if(in==80) vMove(1,0);
					if(in==75) vMove(0,-1);
					if(in==77) vMove(0,1);
				}
			}while(in!=&#39; &#39;&amp;amp;&amp;amp;in!=&#39;f&#39;);
			if(in==&#39;f&#39;) cur=false;
		}
		vDecide(&#39;A&#39;);
		vDecide(&#39;B&#39;);
		vPlus();
	}
}

void vMain1()
{
	int in;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&amp;lt;&amp;lt;&amp;quot;count=&amp;quot;&amp;lt;&amp;lt;nCount&amp;lt;&amp;lt;endl;
		do
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMove(-1,0);
				if(in==80) vMove(1,0);
				if(in==75) vMove(0,-1);
				if(in==77) vMove(0,1);
			}
		}while(in!=&#39;w&#39;&amp;amp;&amp;amp;in!=&#39;s&#39;&amp;amp;&amp;amp;in!=&#39;a&#39;&amp;amp;&amp;amp;in!=&#39;d&#39;&amp;amp;&amp;amp;in!=&#39;z&#39;&amp;amp;&amp;amp;in!=&#39; &#39;);
		if(in==&#39;w&#39;) vMoveNum(-1,0,&#39;A&#39;);
		if(in==&#39;s&#39;) vMoveNum(1,0,&#39;A&#39;);
		if(in==&#39;a&#39;) vMoveNum(0,-1,&#39;A&#39;);
		if(in==&#39;d&#39;) vMoveNum(0,1,&#39;A&#39;);
		if(in==&#39;z&#39;)
		{
			in=getch();
			if(in==&#39;w&#39;) vDiv(-1,0,&#39;A&#39;);
			if(in==&#39;s&#39;) vDiv(1,0,&#39;A&#39;);
			if(in==&#39;a&#39;) vDiv(0,-1,&#39;A&#39;);
			if(in==&#39;d&#39;) vDiv(0,1,&#39;A&#39;);
		}
		vDecide(&#39;B&#39;);
		vPlus();
	}
}

void vMain2()
{
	int in;
	vInit();
	for(nCount=0;;nCount++)
	{
		gotoxy(msize,0);
		color(15,0);
		cout&amp;lt;&amp;lt;&amp;quot;count=&amp;quot;&amp;lt;&amp;lt;nCount;
		vMove(-sx,-sy);
		gotoxy(msize+1,0);
		cout&amp;lt;&amp;lt;&amp;quot;red &amp;quot;;
		do
		{
			in=getch();
			if(in==&#39;w&#39;) vMove(-1,0);
			if(in==&#39;s&#39;) vMove(1,0);
			if(in==&#39;a&#39;) vMove(0,-1);
			if(in==&#39;d&#39;) vMove(0,1);
		}while(in!=&#39;x&#39;&amp;amp;&amp;amp;in!=&#39;z&#39;&amp;amp;&amp;amp;in!=&#39; &#39;);
		if(in==&#39;x&#39;)
		{
			in=getch();
			if(in==&#39;w&#39;) vMoveNum(-1,0,&#39;A&#39;);
			if(in==&#39;s&#39;) vMoveNum(1,0,&#39;A&#39;);
			if(in==&#39;a&#39;) vMoveNum(0,-1,&#39;A&#39;);
			if(in==&#39;d&#39;) vMoveNum(0,1,&#39;A&#39;);
		}
		else if(in==&#39;z&#39;)
		{
			in=getch();
			if(in==&#39;w&#39;) vDiv(-1,0,&#39;A&#39;);
			if(in==&#39;s&#39;) vDiv(1,0,&#39;A&#39;);
			if(in==&#39;a&#39;) vDiv(0,-1,&#39;A&#39;);
			if(in==&#39;d&#39;) vDiv(0,1,&#39;A&#39;);
		}
		vEnd();
		////////////////////////////////
		vMove(msize-1-sx,msize-1-sy);
		gotoxy(msize+1,0);
		color(15,0);
		cout&amp;lt;&amp;lt;&amp;quot;blue&amp;quot;;
		do
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMove(-1,0);
				if(in==80) vMove(1,0);
				if(in==75) vMove(0,-1);
				if(in==77) vMove(0,1);
			}
		}while(in!=&#39;n&#39;&amp;amp;&amp;amp;in!=&#39;m&#39;&amp;amp;&amp;amp;in!=&#39; &#39;);
		if(in==&#39;m&#39;)
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vMoveNum(-1,0,&#39;B&#39;);
				if(in==80) vMoveNum(1,0,&#39;B&#39;);
				if(in==75) vMoveNum(0,-1,&#39;B&#39;);
				if(in==77) vMoveNum(0,1,&#39;B&#39;);
			}
		}
		else if(in==&#39;n&#39;)
		{
			in=getch();
			if(in==224) 
			{
				in=getch();
				if(in==72) vDiv(-1,0,&#39;B&#39;);
				if(in==80) vDiv(1,0,&#39;B&#39;);
				if(in==75) vDiv(0,-1,&#39;B&#39;);
				if(in==77) vDiv(0,1,&#39;B&#39;);
			}
		}
		vPlus();
	}
}

void vInit()
{
	int i,j,x,y;
	string sSeed; 
	unsigned int sd=20190622;
	cout&amp;lt;&amp;lt;&amp;quot;seed:&amp;quot;&amp;lt;&amp;lt;endl;
	cin&amp;gt;&amp;gt;sSeed;
	system(&amp;quot;cls&amp;quot;);
	for(i=0;i&amp;lt;sSeed.size();i++) sd=sd*233+sSeed[i];
	srand(sd);
	cMap[0][0]=&#39;A&#39;;
	hp[0][0]=pmain;
	vChange(0,0);
	cMap[msize-1][msize-1]=&#39;B&#39;;
	hp[msize-1][msize-1]=pmain;
	vChange(msize-1,msize-1);
	for(i=1;i&amp;lt;=mount;i++)
	{
		x=rand()%msize;
		y=rand()%msize;
		if(cMap[x][y]!=0) i--;
		else
		{
			cMap[x][y]=&#39;X&#39;;
			gotoxy(x,y*3);
			color(15,0);
			cout&amp;lt;&amp;lt;&amp;quot; X&amp;quot;;
		}
	}
	for(i=1;i&amp;lt;=grey;i++)
	{
		x=rand()%msize;
		y=rand()%msize;
		if(cMap[x][y]!=0) i--;
		else
		{
			cMap[x][y]=&#39;C&#39;;
			hp[x][y]=40+rand()%10;
			vChange(x,y);
		}
	}
	sx=sy=0;
	gotoxy(0,2);
	color(15,0);
	cout&amp;lt;&amp;lt;&amp;quot;&amp;lt;&amp;quot;;
}

void vMove(int dx,int dy)
{
	color(15,0);
	dx+=sx;dy+=sy;
	if(!(dx&amp;gt;=0&amp;amp;&amp;amp;dx&amp;lt;msize&amp;amp;&amp;amp;dy&amp;gt;=0&amp;amp;&amp;amp;dy&amp;lt;msize)) return;
	gotoxy(sx,sy*3+2);
	cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
	sx=dx;sy=dy;
	gotoxy(sx,sy*3+2);
	cout&amp;lt;&amp;lt;&amp;quot;&amp;lt;&amp;quot;;
	gotoxy(msize+1,0);
	cout&amp;lt;&amp;lt;&amp;quot;cMap=&amp;quot;&amp;lt;&amp;lt;cMap[dx][dy]&amp;lt;&amp;lt;&amp;quot;,hp=&amp;quot;&amp;lt;&amp;lt;hp[dx][dy]&amp;lt;&amp;lt;&amp;quot;            &amp;quot;;
}

void vMoveNum(int x,int y,int dx,int dy,char A)
{
	char a,B,b;
	a=A-&#39;A&#39;+&#39;a&#39;;
	B=(A==&#39;A&#39;)?&#39;B&#39;:&#39;A&#39;;
	b=B-&#39;A&#39;+&#39;a&#39;;
	if(cMap[x][y]!=a&amp;amp;&amp;amp;cMap[x][y]!=A) return;
	dx+=x;dy+=y;
	if(!(dx&amp;gt;=0&amp;amp;&amp;amp;dx&amp;lt;msize&amp;amp;&amp;amp;dy&amp;gt;=0&amp;amp;&amp;amp;dy&amp;lt;msize&amp;amp;&amp;amp;cMap[dx][dy]!=&#39;X&#39;)) return;
	char &amp;amp;cd=cMap[dx][dy];
	int &amp;amp;hd=hp[dx][dy],&amp;amp;hs=hp[x][y];
	if(cd!=a&amp;amp;&amp;amp;cd!=A&amp;amp;&amp;amp;hd&amp;gt;=hs-1) return;
	if(cd==0)
	{
		cd=a;
		hd=hs-1;
	}
	else if(cd==A||cd==a)
	{
		hd+=hs-1;
	}
	else if(cd==B||cd==b)
	{
		if(B==&#39;B&#39;) cd--;
		else cd++;
		hd=hs-1-hd;
	}
	else//&#39;C&#39;
	{
		cd=A;
		hd=hs-1-hd;
	}
	hs=1;
	vChange(dx,dy);
	vChange(x,y);
}

void vMoveNum(int dx,int dy,char A)
{
	vMoveNum(sx,sy,dx,dy,A);
	vMove(dx,dy);
}

void vDiv(int dx,int dy,char A)
{
	char a,B,b;
	a=A-&#39;A&#39;+&#39;a&#39;;
	B=(A==&#39;A&#39;)?&#39;B&#39;:&#39;A&#39;;
	b=B-&#39;A&#39;+&#39;a&#39;;
	if(cMap[sx][sy]!=a&amp;amp;&amp;amp;cMap[sx][sy]!=A) return;
	dx+=sx;dy+=sy;
	if(!(dx&amp;gt;=0&amp;amp;&amp;amp;dx&amp;lt;msize&amp;amp;&amp;amp;dy&amp;gt;=0&amp;amp;&amp;amp;dy&amp;lt;msize&amp;amp;&amp;amp;cMap[dx][dy]!=&#39;X&#39;)) return;
	char &amp;amp;cd=cMap[dx][dy];
	int &amp;amp;hd=hp[dx][dy],&amp;amp;hs=hp[sx][sy],tmp=hs/2;
	if(tmp==0) return;
	if(cd!=a&amp;amp;&amp;amp;cd!=A&amp;amp;&amp;amp;hd&amp;gt;=tmp-1) return;
	if(cd==0)
	{
		cd=a;
		hd=tmp;
	}
	else if(cd==A||cd==a)
	{
		hd+=tmp;
	}
	else if(cd==B||cd==b)
	{
		if(B==&#39;B&#39;) cd--;
		else cd++;
		hd=tmp-hd;
	}
	else//&#39;C&#39;
	{
		cd=A;
		hd=tmp-hd;
	}
	hs-=tmp;
	vChange(dx,dy);
	vChange(sx,sy);
	vMove(dx-sx,dy-sy);
}

void vDecide(char A)
{
	char a,B,b;
	a=A-&#39;A&#39;+&#39;a&#39;;
	B=(A==&#39;A&#39;)?&#39;B&#39;:&#39;A&#39;;
	b=B-&#39;A&#39;+&#39;a&#39;;
	int i,j,k,x,y,dx,dy;
	dRet tmp,res;
	bool bd=false,bm=false;
	for(i=(A==&#39;A&#39;)?0:(msize-1);(A==&#39;A&#39;)?(i&amp;lt;=msize-1):(i&amp;gt;=0);(A==&#39;A&#39;)?(i++):(i--))
	{
		for(j=(A==&#39;A&#39;)?0:(msize-1);(A==&#39;A&#39;)?(j&amp;lt;=msize-1):(j&amp;gt;=0);(A==&#39;A&#39;)?(j++):(j--))
		{
			if(!bd&amp;amp;&amp;amp;(cMap[i][j]==B||cMap[i][j]==&#39;C&#39;))
			{
				tmp=bfs(i,j,A);
				if(tmp.dx+tmp.dy==0) continue;
				bd=true;
				res=tmp;
			}
			if(!bd&amp;amp;&amp;amp;!bm&amp;amp;&amp;amp;(cMap[i][j]==A||cMap[i][j]==a)&amp;amp;&amp;amp;hp[i][j]&amp;gt;1)
			{
				for(k=0;k&amp;lt;4;k++)
				{
					dx=dir[k][0]+i;
					dy=dir[k][1]+j;
					if(!(dx&amp;gt;=0&amp;amp;&amp;amp;dx&amp;lt;msize&amp;amp;&amp;amp;dy&amp;gt;=0&amp;amp;&amp;amp;dy&amp;lt;msize)) continue;
					if((cMap[dx][dy]==0||cMap[dx][dy]==b)&amp;amp;&amp;amp;hp[dx][dy]&amp;lt;hp[i][j]-1)
					{
						bm=true;
						res.dx=dir[k][0];
						res.dy=dir[k][1];
						res.x=i;
						res.y=j;
						break;
					}
				}
			}
			if(bd) break;
		}
		if(bd) break;
	}
	if(!bd&amp;amp;&amp;amp;!bm) return;
	vMoveNum(res.x,res.y,res.dx,res.dy,A);
}

dRet bfs(int x,int y,char A)
{
	char a,B,b;
	a=A-&#39;A&#39;+&#39;a&#39;;
	B=(A==&#39;A&#39;)?&#39;B&#39;:&#39;A&#39;;
	b=B-&#39;A&#39;+&#39;a&#39;;
	int i,dx,dy;
	dRet ret;
	node now,nxt;
	queue&amp;lt;node&amp;gt;q;
	now.step=hp[x][y]+2;
	now.x=x;
	now.y=y;
	q.push(now);
	memset(bVis,false,sizeof bVis);
	bVis[x][y]=true;
	while(!q.empty())
	{
		now=q.front();
		q.pop();
		for(i=0;i&amp;lt;4;i++)
		{
			dx=dir[i][0]+now.x;
			dy=dir[i][1]+now.y;
			if(dx&amp;gt;=0&amp;amp;&amp;amp;dx&amp;lt;msize&amp;amp;&amp;amp;dy&amp;gt;=0&amp;amp;&amp;amp;dy&amp;lt;msize&amp;amp;&amp;amp;!bVis[dx][dy]&amp;amp;&amp;amp;cMap[dx][dy]!=&#39;X&#39;)
			{
				bVis[dx][dy]=true;
				if(cMap[dx][dy]==0) nxt.step=now.step+1;
				if(cMap[dx][dy]==b||cMap[dx][dy]==B||cMap[dx][dy]==&#39;C&#39;) nxt.step=now.step+hp[dx][dy]+2;
				else
				{
					nxt.step=now.step-hp[dx][dy]+1;
					if(nxt.step&amp;lt;-5&amp;amp;&amp;amp;(cMap[dx][dy]==A||cMap[dx][dy]==a))
					{
						ret.dx=-dir[i][0];
						ret.dy=-dir[i][1];
						ret.x=dx;
						ret.y=dy;
						return ret;
					}
				}
				nxt.x=dx;
				nxt.y=dy;
				q.push(nxt);
			}
		}
	}
	ret.dx=ret.dy=0;
	return ret;
}

void vPlus()
{
	int i,j,aa=0,ba=0,al=0,bl=0;
	if(nCount%lcnt==0)
	{
		for(i=0;i&amp;lt;msize;i++)
		{
			for(j=0;j&amp;lt;msize;j++)
			{
				if(cMap[i][j]==&#39;a&#39;||cMap[i][j]==&#39;b&#39;)
				{
					hp[i][j]++;
					vChange(i,j);
				}
			}
		}
	}
	for(i=0;i&amp;lt;msize;i++)
	{
		for(j=0;j&amp;lt;msize;j++)
		{
			if(cMap[i][j]==&#39;A&#39;||cMap[i][j]==&#39;B&#39;)
			{
				hp[i][j]+=pmain;
				vChange(i,j);
			}
			if(cMap[i][j]==&#39;A&#39;||cMap[i][j]==&#39;a&#39;) al++,aa+=hp[i][j];
			if(cMap[i][j]==&#39;B&#39;||cMap[i][j]==&#39;b&#39;) bl++,ba+=hp[i][j];
		}
	}
	color(15,0);
	gotoxy(msize+2,0);
	cout&amp;lt;&amp;lt;&amp;quot;red army:&amp;quot;&amp;lt;&amp;lt;aa&amp;lt;&amp;lt;&amp;quot;   &amp;quot;&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;&amp;quot;red land:&amp;quot;&amp;lt;&amp;lt;al&amp;lt;&amp;lt;&amp;quot;   &amp;quot;&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;&amp;quot;blue army:&amp;quot;&amp;lt;&amp;lt;ba&amp;lt;&amp;lt;&amp;quot;   &amp;quot;&amp;lt;&amp;lt;endl;
	cout&amp;lt;&amp;lt;&amp;quot;blue land:&amp;quot;&amp;lt;&amp;lt;bl&amp;lt;&amp;lt;&amp;quot;   &amp;quot;&amp;lt;&amp;lt;endl;
	vEnd();
}

void vEnd()
{

	if(cMap[0][0]==&#39;B&#39;)
	{
		cout&amp;lt;&amp;lt;&amp;quot;blue win&amp;quot;&amp;lt;&amp;lt;endl;
		while(1);
	}
	if(cMap[msize-1][msize-1]==&#39;A&#39;)
	{
		cout&amp;lt;&amp;lt;&amp;quot;red win&amp;quot;&amp;lt;&amp;lt;endl;
		while(1);
	}
}

void vChange(int x,int y)
{
	int c;
	char cm=cMap[x][y];
	if(cm==&#39;A&#39;) c=cA;
	if(cm==&#39;a&#39;) c=ca;
	if(cm==&#39;B&#39;) c=cB;
	if(cm==&#39;b&#39;) c=cb;
	if(cm==&#39;C&#39;) c=cC;
	gotoxy(x,y*3);
	color(15,c);
	int val=hp[x][y];
	if(val&amp;lt;10) cout&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;val;
	else if(val&amp;lt;100) cout&amp;lt;&amp;lt;val;
	else if(val&amp;lt;1000) cout&amp;lt;&amp;lt;val/100&amp;lt;&amp;lt;&amp;quot;e&amp;quot;;
	else if(val&amp;lt;10000) cout&amp;lt;&amp;lt;val/1000&amp;lt;&amp;lt;&amp;quot;k&amp;quot;;
	else if(val&amp;lt;100000) cout&amp;lt;&amp;lt;val/10000&amp;lt;&amp;lt;&amp;quot;w&amp;quot;;
	else cout&amp;lt;&amp;lt;&amp;quot;ju&amp;quot;;
}

void gotoxy(int x,int y)
{
	COORD c;
	c.X=y;
	c.Y=x;
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),c);
}

void color(int t,int b)
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),t+b*16);
}
&lt;/code&gt;&lt;/pre&gt;
">如何用C++玩generals.io</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/xiong-ya-li-suan-fa-zong-jie/"" data-c="
          &lt;h3 id=&#34;part-0前言&#34;&gt;Part 0：前言&lt;/h3&gt;
&lt;p&gt;学了这个算法好多次了，是时候总结一下啦😆&lt;/p&gt;
&lt;h3 id=&#34;part-1几个概念&#34;&gt;Part 1：几个概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;二分图&lt;/strong&gt;：一类特殊的图，它可以被划分为两个部分，每个部分内的点互不相连。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最大匹配数&lt;/strong&gt;：二分图中没有公共端点的边的数量的最大值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小点覆盖&lt;/strong&gt;：我们想找到最少的一些点，使二分图所有的边都至少有一个端点在这些点之中。倒过来说就是，删除包含这些点的边，可以删掉所有边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;匈牙利算法&lt;/strong&gt;：一种用来解决&lt;strong&gt;最大匹配数&lt;/strong&gt;和&lt;strong&gt;最小点覆盖&lt;/strong&gt;问题的算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;part-2二分图最大匹配问题&#34;&gt;Part 2：二分图最大匹配问题&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yydcc-blog.github.io//post-images/1642164375763.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里举例一个二分图，来模拟匹配的过程。&lt;/p&gt;
&lt;p&gt;很明显，这里的最大匹配是3。&lt;/p&gt;
&lt;h4 id=&#34;匈牙利算法的过程模拟&#34;&gt;匈牙利算法的过程模拟：&lt;/h4&gt;
&lt;p&gt;我们先暂时把1和2连在一起。&lt;/p&gt;
&lt;p&gt;现在3也可以和2连，这时我们返过去看和2相连的1。&lt;/p&gt;
&lt;p&gt;由于1只能和2连，所以3连不上2。&lt;/p&gt;
&lt;p&gt;那么3还有选择么？有，可以和6连。&lt;/p&gt;
&lt;p&gt;这时6只能和3连。&lt;/p&gt;
&lt;p&gt;再看4，和5连即可。&lt;/p&gt;
&lt;p&gt;这就是匈牙利算法的流程，至于具体实现，我们来看看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int M, N;            //M, N分别表示左、右侧集合的元素数量
int Map[MAXM][MAXN]; //邻接矩阵存图
int p[MAXN];         //记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      //记录右侧元素是否已被访问过
bool match(int i){
    for (int j = 1; j &amp;lt;= N; ++j)
        if (Map[i][j] &amp;amp;&amp;amp; !vis[j]){ //有边且未访问
            vis[j] = true;                 //记录状态为访问过
            if (p[j] == 0 || match(p[j])){ //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
        }
    return false; //循环结束，仍未找到匹配，返回匹配失败
}
int Hungarian(){
    int cnt = 0;
    for (int i = 1; i &amp;lt;= M; ++i){
        memset(vis, 0, sizeof(vis)); //重置vis数组
        if (match(i))
            cnt++;
    }
    return cnt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过算法我们可以发现，单次找边的过程是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(m)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的，一共有 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个点，所以总体复杂度为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(nm)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（因为复杂度大，所以题目的限制一般较大，可以直接用邻接矩阵存储）&lt;/p&gt;
&lt;h3 id=&#34;part-3二分图最小点覆盖问题&#34;&gt;Part 3：二分图最小点覆盖问题&lt;/h3&gt;
&lt;p&gt;这里引入&lt;strong&gt;König定理&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二分图中的最大匹配数等于这个图中的最小点覆盖数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接解决。&lt;/p&gt;
&lt;h3 id=&#34;part-4例题&#34;&gt;Part 4：例题&lt;/h3&gt;
&lt;p&gt;这里只举例一题：&lt;strong&gt;洛谷 P1129 [ZJOI2007] 矩阵游戏&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;×&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n \times n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;×&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：&lt;br&gt;
行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。&lt;br&gt;
列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。&lt;br&gt;
游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。&lt;br&gt;
对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过枚举样例，我们发现：任意2个黑色方块，如果它们初始状态时不在同一行（列），那么无论如何交换，它们都不会在同一行（列）。&lt;/p&gt;
&lt;p&gt;所以我们只需判断每一行是否都可以合法匹配即可。&lt;/p&gt;
&lt;p&gt;AC代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int mp[205][205],p[205],vis[205],n,T;
bool match(int i){
	for(int j=1;j&amp;lt;=n;j++) {
		if(mp[i][j]&amp;amp;&amp;amp;!vis[j]){
			vis[j]=1;
			if(!p[j]||match(p[j])) {
				p[j]=i;
				return 1;
			}
		}
	}
	return 0;
}
int Hungarian(){
	int cnt=0;
	for (int i=1;i&amp;lt;=n;i++) {
		memset(vis,0,sizeof(vis));
		if (match(i))cnt++;
	}
	return cnt;
}
int main() {
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--){
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		memset(p,0,sizeof(p));
		for(int i=1;i&amp;lt;=n;i++)
			for(int j=1;j&amp;lt;=n;j++)
				scanf(&amp;quot;%d&amp;quot;,&amp;amp;mp[i][j]);
		if(Hungarian()==n)puts(&amp;quot;Yes&amp;quot;);
		else puts(&amp;quot;No&amp;quot;);
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;part-5总结&#34;&gt;Part 5：总结&lt;/h3&gt;
&lt;p&gt;匈牙利算法是一个比较基础的图论算法，思路较简单，一定要记牢啊😙&lt;/p&gt;
">匈牙利算法总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/ni-hao-csp-j-2021/"" data-c="
          &lt;h3 id=&#34;day-27&#34;&gt;Day -27：&lt;/h3&gt;
&lt;p&gt;今年复赛终于进了，压线两分。&lt;/p&gt;
&lt;p&gt;我觉得只要进了就好，没别的要求。&lt;/p&gt;
&lt;p&gt;S组差亿点点QWQ。&lt;br&gt;
&lt;img src=&#34;https://xn--9zr.tk/kk&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;day-26&#34;&gt;Day -26：&lt;/h3&gt;
&lt;p&gt;开始准备复赛。&lt;/p&gt;
&lt;p&gt;搞了一些网课什么的，模拟赛打一打。&lt;s&gt;鱼摸一摸&lt;/s&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;day-1-afternoon&#34;&gt;Day -1 afternoon：&lt;/h3&gt;
&lt;p&gt;逃了学校的两堂课，直接出发去酒店。&lt;/p&gt;
&lt;p&gt;晚上大吃一顿然后看看防爆零事项什么的。&lt;/p&gt;
&lt;p&gt;总体来说准备很充分，剩下的看老天爷了。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;day-1-night&#34;&gt;Day -1 night：&lt;/h3&gt;
&lt;p&gt;杭州真的好热，晚上有睡没睡的。&lt;br&gt;
&lt;img src=&#34;https://xn--9zr.tk/kk&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;day-1-morning&#34;&gt;Day 1 morning：&lt;/h3&gt;
&lt;p&gt;在酒店大堂吃了顿早餐就出发了。&lt;/p&gt;
&lt;p&gt;在门口遇见一堆大佬（wjz ghj yjy sk）&lt;/p&gt;
&lt;p&gt;进场时绕了好久，在考场外等了好久。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;day-1-csp-j-2021&#34;&gt;Day 1 CSP-J-2021：&lt;/h3&gt;
&lt;p&gt;今年出题人是真的良心。&lt;/p&gt;
&lt;p&gt;四道题三道模拟一道暴力。（bushi）&lt;/p&gt;
&lt;p&gt;T1就是一道数学题，模几个样例就想到做法了。&lt;/p&gt;
&lt;p&gt;然后我先做了T3，根据大样例找了好久的错。&lt;/p&gt;
&lt;p&gt;这时比赛已经过半了（T3 98行代码自愧不如）&lt;br&gt;
&lt;img src=&#34;https://xn--9zr.tk/kk&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;T2读了好久的题，草稿纸都快写满了。&lt;/p&gt;
&lt;p&gt;突然发现好水然后测了大样例就去做T4了。&lt;/p&gt;
&lt;p&gt;T4链表写炸，最后用了个暴力。&lt;/p&gt;
&lt;p&gt;一开始直接用肉眼看大样例答案，后来想到可以用cmd的fc，但又不会改目录，就写了一个check来判断。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;day-1-noon&#34;&gt;Day 1 noon：&lt;/h3&gt;
&lt;p&gt;比完后在附近吃了饭，然后就退房返城。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;day-n&#34;&gt;Day n:&lt;/h3&gt;
&lt;p&gt;洛谷自测300+&lt;/p&gt;
&lt;p&gt;J组1=，满足了&lt;/p&gt;
&lt;h2 id=&#34;再见csp-j-2021&#34;&gt;再见！CSP-J-2021&lt;/h2&gt;
&lt;h6 id=&#34;补充个人认为难度t4t2t3t1&#34;&gt;补充：个人认为难度T4&amp;gt;T2&amp;gt;T3&amp;gt;T1&lt;/h6&gt;
">你好！CSP-J-2021</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/yorgio-jin-jie-gong-lue/"" data-c="
          &lt;p&gt;这是我精心编写的攻略，喜欢大家喜欢😄&lt;/p&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;这是一个休闲类塔防网页游戏，也有单机版。&lt;/p&gt;
&lt;p&gt;游戏地址：&lt;a href=&#34;https://yorg.io/&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;第一步度过前期第1~50天&#34;&gt;第一步：度过前期（第1~50天）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基地建在附近有最多水晶的地方，水晶之间距离越近越好。&lt;/li&gt;
&lt;li&gt;前十几关都不需要建攻击塔，所有经济用于升级基地、水晶以及建墙，把所有水晶矿机升级到最高级。&lt;/li&gt;
&lt;li&gt;前期不用建攻击塔怎么解决掉小兵和boss呢？靠墙拖着，拖到白天，所有小兵和boss都会在3/4的白天前被烧死，基地本身有的攻击力也会发挥作用。建墙有一定的技巧，一是在墙快要被摧毁的时候升级，它就回到满血状态，这样可以把时间拖到最长，操作的注意点是受到攻击时经常性按下暂停，升级墙；二是只需要特别加强4个方向的墙：东南、东北、西南、西北，大部分小兵主要是攻击这4个方向，三是保险一点围2层的墙，在4个方向上可以加到3-4层；&lt;/li&gt;
&lt;li&gt;基地升到第6级时，开始建闪电塔，闪电塔是最有效的攻击武器；不要建其他攻击塔；&lt;/li&gt;
&lt;li&gt;前期把所有技能点都点到提升矿机生产效率上，然后是工厂生产，最后是闪电攻击；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tips&#34;&gt;tips:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;boss一般是在防御最弱的方向发起攻击的；&lt;/li&gt;
&lt;li&gt;如果你的建筑相隔较远，比如矿机、工厂和攻击塔之间，最好将连接的传输器升到最高级，这样可以大大加快运输的速度，快速补充弹药；&lt;/li&gt;
&lt;li&gt;如果某一关搞砸了，可以读取存档，不过会损失一些资源；如果你在白天保存游戏，然后回到主界面，再进入，小兵就会消失（算是作弊把..）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;结束前期这时level10-现有水晶在1千万以上&#34;&gt;结束前期，这时Level10+。现有水晶在1千万以上。&lt;/h4&gt;
&lt;h3 id=&#34;第二步初步转型50天后&#34;&gt;第二步：初步转型（50天后）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;拆除你的所有设施。&lt;/li&gt;
&lt;li&gt;重新安排你的水晶矿机，围绕着主基地排列。&lt;/li&gt;
&lt;li&gt;重新安排其他矿机，让他们围绕着水晶矿机排列，我们把这个区域叫做一个矿区。&lt;/li&gt;
&lt;li&gt;用运输线连接矿机，将各种工厂安置在运输线上。（如果你已经解锁了空间翘曲技术，请跳过这步）&lt;/li&gt;
&lt;li&gt;在每个矿区周围安置弓箭塔8个，闪电塔4个。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第三步围墙转型&#34;&gt;第三步：围墙转型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果水晶多，定位到地图的边缘，按住字母E的同时按住ASDW控制方向，绘制出连续的城墙。&lt;/li&gt;
&lt;li&gt;如果水晶少，在每个矿区周围搭建围墙。&lt;/li&gt;
&lt;li&gt;制造僵尸通道（在围墙上开洞通往主基地）&lt;/li&gt;
&lt;li&gt;在这个通道周围布满武器塔。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第四步还没有第四步&#34;&gt;第四步：还没有第四步😙&lt;/h3&gt;
">yorg.io 进阶攻略</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/cf222b-cosmic-tables-ti-jie/"" data-c="
          &lt;h2 id=&#34;分糖果&#34;&gt;分糖果&lt;/h2&gt;
&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;
&lt;p&gt;选择&lt;code&gt;L~R&lt;/code&gt;中的某个数 ， 使得&lt;code&gt;x mod k&lt;/code&gt;的结果最大。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;分两种情况考虑：&lt;/p&gt;
&lt;p&gt;若 L 和 R 对 K 取模后在同一区间，则必然在 x=R 位置取到最大值；&lt;br&gt;
否则 L~R 必然跨越多个区间，则取模后的结果必然有 k-1。&lt;br&gt;
而对于是否在同一区间，在除以 k 后，商是否一致判断即可。&lt;/p&gt;
&lt;h3 id=&#34;参考代码&#34;&gt;参考代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
int main() {
  ll n, l, r;
  cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
  if (l / n != r / n) cout &amp;lt;&amp;lt; n - 1 &amp;lt;&amp;lt; endl;
  else cout &amp;lt;&amp;lt; r % n &amp;lt;&amp;lt; endl;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;插入排序&#34;&gt;插入排序&lt;/h2&gt;
&lt;h3 id=&#34;题意-2&#34;&gt;题意&lt;/h3&gt;
&lt;p&gt;给定长度为 n 的整数序列 ，有 Q 种操作：&lt;/p&gt;
&lt;p&gt;1：x v 修改序列 a 中的第 x 个元素 &lt;code&gt;a[x]&lt;/code&gt; 为 v ，该操作次数不超过5000次；&lt;br&gt;
2：x 将数组进行稳定排序，求原先第 x 个元素排序后的位置。&lt;/p&gt;
&lt;h3 id=&#34;思路-2&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;不如维护将原先所有的 a 排序后的升序数组。对于所有操作，我们需要维护原位置到有序数组中的映射。&lt;/p&gt;
&lt;p&gt;对于 1 操作，找到 &lt;code&gt;a[x]&lt;/code&gt; 对应位置，显然修改值将使其往前或往后。联系到题目中提示的插入排序，可以不断向前/向后比较。注意同时维护映射关系。&lt;br&gt;
对于 2 操作，直接输出映射即可。&lt;br&gt;
注：如果该题中的数组长度更长、操作次数更多，我们可使用平衡树来解决该题。&lt;/p&gt;
&lt;h3 id=&#34;参考代码-2&#34;&gt;参考代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef pair&amp;lt;int, int&amp;gt; pii;
const int N = 8e3+5;
int a[N];
pii p[N];

int main() {
  ios::sync_with_stdio(false);
  int n, q; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
  for (int i = 1; i &amp;lt;= n; i++) {
    cin &amp;gt;&amp;gt; a[i];
    p[i] = {a[i], i};
  }
  sort(p + 1, p + 1 + n);
  for (int i = 1; i &amp;lt;= n; i++) a[p[i].second] = i;
  for (int i = 0, op, x, v; i &amp;lt; q; i++) {
    cin &amp;gt;&amp;gt; op; 
    // 5000 * 8000 = 4e7
    if (op == 1) {
      cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
      int pos = a[x];
      p[pos].first = v;
      while (pos &amp;gt; 1 &amp;amp;&amp;amp; p[pos] &amp;lt; p[pos - 1]) {
        swap(a[p[pos].second], a[p[pos - 1].second]);
        swap(p[pos], p[pos - 1]);
        pos--;
      } 
      while (pos &amp;lt; n &amp;amp;&amp;amp; p[pos] &amp;gt; p[pos + 1]) {
        swap(a[p[pos].second], a[p[pos + 1].second]);
        swap(p[pos], p[pos + 1]);
        pos++;
      }
    } else {
      cin &amp;gt;&amp;gt; x;
      cout &amp;lt;&amp;lt; a[x] &amp;lt;&amp;lt; endl;
    }
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;网络连接&#34;&gt;网络连接&lt;/h2&gt;
&lt;h3 id=&#34;题意-3&#34;&gt;题意&lt;/h3&gt;
&lt;p&gt;解析带端口的IP地址串，按服务器和客户端角色判断连接情况。&lt;/p&gt;
&lt;h3 id=&#34;思路-3&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;若将带端口的IP地址串记为 a.b.c.d:e，则需要检查的项目有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有三个点号和一个冒号分隔字符串，且冒号出现在最后；&lt;/li&gt;
&lt;li&gt;a,b,c,d,e均不为空，且不含有前导零；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可将对字符串的解析抽象为函数，简化代码逻辑。&lt;/p&gt;
&lt;h3 id=&#34;参考代码-3&#34;&gt;参考代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
map&amp;lt;string, int&amp;gt; dict;
const int IP = 256;
const int PORT = 65536;

bool check(string s, int limit) {
  // &amp;quot;.0.0.1:80&amp;quot; -&amp;gt; &amp;quot;&amp;quot;
  if (s.empty()) return false;
  // &amp;quot;0127.0.0.1:80&amp;quot; -&amp;gt; &amp;quot;0127&amp;quot;
  if (s[0] == &#39;0&#39; &amp;amp;&amp;amp; s.size() &amp;gt; 1) return false;
  int val = 0;
  for (int i = 0; i &amp;lt; s.size(); i++) {
    val = val * 10 + s[i] - &#39;0&#39;; 
    if (val &amp;gt;= limit) return false;
  }
  return true;
}

bool parse(string ip) {
  string s = &amp;quot;&amp;quot;;
  int dot_cnt = 0, port_cnt = 0;
  for (int i = 0; i &amp;lt; ip.size(); i++) {
    if (ip[i] == &#39;.&#39;) dot_cnt += 1;
    if (ip[i] == &#39;:&#39;) {
      if (dot_cnt != 3) return false;
      port_cnt += 1;
    }
    if (!isdigit(ip[i])) {
      if (!check(s, IP)) return false;
      s = &amp;quot;&amp;quot;;
    } else s += ip[i];
  }
  return check(s, PORT) &amp;amp;&amp;amp; dot_cnt == 3 &amp;amp;&amp;amp; port_cnt == 1;
}

void process_server(string ip, int id) {
  bool valid = parse(ip);
  if (!valid) {cout &amp;lt;&amp;lt; &amp;quot;ERR&amp;quot; &amp;lt;&amp;lt; endl; return;}
  if (dict.count(ip)) {cout &amp;lt;&amp;lt; &amp;quot;FAIL&amp;quot; &amp;lt;&amp;lt; endl; return;}
  dict[ip] = id;
  cout &amp;lt;&amp;lt; &amp;quot;OK&amp;quot; &amp;lt;&amp;lt; endl;
}

void process_client(string ip) {
  bool valid = parse(ip);
  if (!valid) {cout &amp;lt;&amp;lt; &amp;quot;ERR&amp;quot; &amp;lt;&amp;lt; endl; return;}
  if (!dict.count(ip)) {cout &amp;lt;&amp;lt; &amp;quot;FAIL&amp;quot; &amp;lt;&amp;lt; endl; return;}
  cout &amp;lt;&amp;lt; dict[ip] &amp;lt;&amp;lt; endl;
}

int main() {
  ios::sync_with_stdio(false);
  int n; cin &amp;gt;&amp;gt; n;
  for (int i = 1; i &amp;lt;= n; i++) {
    string name, ip;
    cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; ip;
    if (name[0] == &#39;S&#39;) process_server(ip, i);
    else process_client(ip);
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;小熊的果篮&#34;&gt;小熊的果篮&lt;/h2&gt;
&lt;h3 id=&#34;题意-4&#34;&gt;题意&lt;/h3&gt;
&lt;p&gt;有两类共 n 个水果拍成一排，称连续的排在一起的同一种水果称为“块”。&lt;/p&gt;
&lt;p&gt;每次将每一个“块”中最左边的水果同时挑出。重复该操作直至水果用完。&lt;/p&gt;
&lt;p&gt;每次水果被挑出后“块”会发生动态变化。&lt;/p&gt;
&lt;h3 id=&#34;思路-4&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;尝试建模每个块，使用块头来表示每个块的开始位置，即第一个元素或与上一个元素类型不同的位置。&lt;/p&gt;
&lt;p&gt;每个元素之间使用双向链表相连接。&lt;/p&gt;
&lt;p&gt;对于每次输出选出的元素，我们只需要依次输出块头元素，并从双向链表中删除该元素。&lt;/p&gt;
&lt;p&gt;当块头元素输出后，需要更新块头列表。&lt;br&gt;
考虑在原块头位置的下一个元素，只有当：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该下一个元素与原块头位置的上一个元素类型不同；&lt;/li&gt;
&lt;li&gt;该下一个元素不是原块头。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则能够成为新的块头位置。&lt;/p&gt;
&lt;h3 id=&#34;参考代码-4&#34;&gt;参考代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 2e5+5;
struct Node {
  int pre, nxt, v;
}a[N];
vector&amp;lt;int&amp;gt; head, nxt_head;

int main() {
  ios::sync_with_stdio(false);
  int n; cin &amp;gt;&amp;gt; n;
  a[0].v = a[n + 1].v = -1;
  a[0].nxt = 1;
  a[n + 1].pre = n;
  for (int i = 1; i &amp;lt;= n; i++) {
    cin &amp;gt;&amp;gt; a[i].v;
    a[i].pre = i - 1;
    a[i].nxt = i + 1;
    if (a[i].v != a[i - 1].v) head.push_back(i);
  }
  while(head.size()) {
    nxt_head.clear();
    for (int id : head) {
      cout &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
      Node&amp;amp; node = a[id];
      a[node.pre].nxt = node.nxt;
      a[node.nxt].pre = node.pre;
      if (node.v == a[node.nxt].v &amp;amp;&amp;amp; node.v != a[node.pre].v)
        nxt_head.push_back(node.nxt);
    }
    cout &amp;lt;&amp;lt; endl;
    swap(head, nxt_head);
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">CSP-J2021 题解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/shu-xing-dp-zong-jie/"" data-c="
          &lt;h1 id=&#34;part-0-前言&#34;&gt;Part 0 前言&lt;/h1&gt;
&lt;p&gt;刚学完了树形DP，是时候来总结一下了！😀&lt;/p&gt;
&lt;h1 id=&#34;part-1-基础部分&#34;&gt;Part 1 基础部分&lt;/h1&gt;
&lt;p&gt;树形DP就是在树上的DP。&lt;/p&gt;
&lt;p&gt;这里先放一下遍历树的模板：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void dfs(int u,int fa){
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		dfs(v);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DP的操作就放在dfs操作的后面，再加上初值和特判，就变成了这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void dfs(int u,int fa){
	|初值定义| 
	if(|特判条件|)|特判操作| 
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		dfs(v);
		|DP操作|
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;part-2-练习部分&#34;&gt;Part 2 练习部分&lt;/h1&gt;
&lt;h3 id=&#34;p1352-没有上司的舞会&#34;&gt;P1352 没有上司的舞会&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：★★☆☆☆&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目大意&lt;/strong&gt;：给你一棵带点权的树，每次只能取父节点的权或子节点的权，求最大的点权和为多少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;：因为能不能区由子节点决定，那么可以设 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_{i  ,0/1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.04964em;vertical-align:-0.3551999999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.34480000000000005em;&#34;&gt;&lt;span style=&#34;top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3551999999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 取（1）和不取（0）的最大权值和。转移方程就为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_{i,1} = f_{j,0} + a_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_{i,0} = max(f_{j,0} , f_{j,1})+ a_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; （&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的子节点，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的权值）。答案就是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;max(f_{root,0},f_{root,1})&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.301108em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.301108em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define maxn 6005
using namespace std;
int n,head[maxn],nex[maxn],to[maxn],f[maxn][2],num[maxn],edgenum;
bool root[maxn];
void addedge(int u,int v){ 
	nex[++edgenum]=head[u];
	to[edgenum]=v;
	head[u]=edgenum;
	root[v]=1;
}
void dp(int u){
	f[u][0]=0;//定义初值 
	f[u][1]=num[u];
	for(int i=head[u];i;i=nex[i]){
		int v=to[i];
		dp(v);
		f[u][0]+=max(f[v][0],f[v][1]);//DP操作 
		f[u][1]+=f[v][0];
	}
}
int main(){
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;=n;i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;num[i]);
	for(int i=1;i&amp;lt;n;i++){
		int u,v;
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;u,&amp;amp;v);
		addedge(v,u);
	}
	for(int i=1;i&amp;lt;=n;i++)
		if(!root[i]){//是否为根节点 
			dp(i);
			printf(&amp;quot;%d\n&amp;quot;,max(f[i][0],f[i][1]));//输出答案 
			break;
		}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;p1122-最大子树和&#34;&gt;P1122 最大子树和&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：★☆☆☆☆&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目大意&lt;/strong&gt;：给你一棵带点权的树，让你求最大的子树权值和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;：因为要求最大子树和，所以设 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_u&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为以节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;u&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为根的最大子树和。&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_u = max(0,f_v)+a_u&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; （&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;v&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;u&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的子节点，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a_u&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;u&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的权值）。答案就是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_u&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的最大值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
struct edge {
	int next,to;
} e[100000];
int n,a[100000],head[100000],cnt,f[100000],ans;
void add(int x,int y) {
	e[++cnt].next=head[x];
	e[cnt].to=y;
	head[x]=cnt;
}
void dfs(int u,int fa) {
	f[u]=a[u];
	for(int i=head[u]; i; i=e[i].next) {
		int v=e[i].to;
		if(v!=fa) { 
			dfs(v,u);
			f[u]+=max(0,f[v]);//相加 
		}
	}
	ans=max(ans,f[u]);//记录最大值 
}
int main() {
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	for(int i=1; i&amp;lt;=n; i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
	for(int i=1;i&amp;lt;n; i++) {
		int x,y; 
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	printf(&amp;quot;%d&amp;quot;,ans);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;p2015-二叉苹果树&#34;&gt;P2015 二叉苹果树&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：★★★☆☆&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目大意&lt;/strong&gt;：给你一棵带点权的二叉树，求一颗有 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Q&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8777699999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;Q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 条边的子树的最大点权和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;：通过样例可以看出这是一道树上的 &lt;a href=&#34;https://baike.baidu.com/item/01%E8%83%8C%E5%8C%85/4301245?fr=aladdin&#34;&gt;01背包&lt;/a&gt; 题目，通过类比思想把状态转化为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_{x,i}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示当前节点 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的子树上保留 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 条边的最大点权和。转移就变成了这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for(int j=q;j&amp;gt;=1;j--)
	for(int k=j-1;k&amp;gt;=0;k--)
		f[x][j]=max(f[x][j],len[i]+f[v][k]+f[x][j-k-1]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搜索，每一个点找出以它为根节点的1~q的最大利益，除叶节点外。因为连接父节点和子节点还有一条边，所以父节点自己留的可用边-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,q;
int f[1005][1005],edgenum,len[1009],head[1009],to[1005],nxt[1005];
void addedge(int u,int v,int l){
	nxt[++edgenum]=head[u];
	to[edgenum]=v;
	len[edgenum]=l;
	head[u]=edgenum;
}
void dfs(int x,int fa){
	for(int i=head[x];i;i=nxt[i]){
		int v=to[i];
		if(v==fa)continue;
		used[v]=1;
		dfs(v,u);
		for(int j=q;j&amp;gt;=1;j--)//01背包要倒着做 
			for(int k=j-1;k&amp;gt;=0;k--)
				f[x][j]=max(f[x][j],len[i]+f[v][k]+f[x][j-k-1]);
	}
}

int main(){
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;q);
	for(int i=1;i&amp;lt;n;i++){
		int x,y,z;
		scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);
		addedge(x,y,z);//双向建边 
		addedge(y,x,z);
	}
	dfs(1,0);
	printf(&amp;quot;%d&amp;quot;,f[1][q]);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;p2014-ctsc1997选课&#34;&gt;P2014 [CTSC1997]选课&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：★★★☆☆&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目大意&lt;/strong&gt;：给你一棵带点权的树，求一棵有 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;M&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个点的子树的最大权值和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;：跟上面一题差不多，只是变成了单向边。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N=305,M=2001;
int f[N][N],edgenum,n,m;
int head[M],nxt[M],to[M];
void addedge(int u,int v){
    nxt[++edgenum]=head[u];
    to[edgenum]=v;
    head[u]=edgenum;
}
void dp(int x){
    for(int e=head[x];e;e=nxt[e]){
        int v=to[e];
        dp(v);
        for(int i=m+1;i&amp;gt;1;i--)
            for(int j=i-1;j&amp;gt;=1;j--)
                f[x][i]=max(f[x][i],f[x][i-j]+f[v][j]);
    }
}
int main(){
    scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1;i&amp;lt;=n;i++){
        int a,b;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b);
        f[i][1]=b;
        addedge(a,i);
    }
    dp(0);
    printf(&amp;quot;%d\n&amp;quot;,f[0][m+1]);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;p1273-有线电视网&#34;&gt;P1273 有线电视网&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：★★★★☆&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目大意&lt;/strong&gt;：选出一个节点数量最多的叶子节点的集合，使这些点到根节点的路径上的权值和减去集合中所有的点的权值大于等于零。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;：设 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_{i,j}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的子树中，选择 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个叶子节点，点权-边权的最大值。&lt;code&gt;dp[u][j]=max(dp[u][j],dp[u][j-i]+dp[v][i]-edge[e].w);&lt;/code&gt;，最后找第一个大于等于零的 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f_{1,i}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.980548em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 即为答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m,head[3010],edgenum,val[3010],dp[3010][3010];
struct node {
	int to,next,w;
} edge[10000];
void adde(int u,int v,int w) {
	edge[++edgenum].to=v;
	edge[edgenum].next=head[u];
	edge[edgenum].w=w;
	head[u]=edgenum;
}
int dfs(int u) {
	if(u&amp;gt;n-m) {
		dp[u][1]=val[u];
		return 1;
	}
	int sum=0,t;
	for(int e=head[u]; e; e=edge[e].next) {
		int v=edge[e].to;
		t=dfs(v);
		sum+=t;
		for(int j=sum; j&amp;gt;0; j--)
			for(int i=1; i&amp;lt;=t; i++)
				if(j-i&amp;gt;=0) dp[u][j]=max(dp[u][j],dp[u][j-i]+dp[v][i]-edge[e].w);
	}
	return sum;
}
int main() {
	memset(dp,~0x3f,sizeof(dp));
	scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
	for(int u=1; u&amp;lt;=n-m; u++) {
		int size,v,w;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;size);
		for(int j=1; j&amp;lt;=size; j++) {
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;v,&amp;amp;w);
			adde(u,v,w);
		}
	}
	for(int i=n-m+1; i&amp;lt;=n; i++)
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;val[i]);
	for (int i=1; i&amp;lt;=n; i++)
		dp[i][0]=0;
	dfs(1);
	for (int i=m; i&amp;gt;=1; i--)
		if (dp[1][i]&amp;gt;=0) {
			printf(&amp;quot;%d&amp;quot;,i);
			break;
		}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">树形DP总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/tui-jian/"" data-c="
          &lt;ul&gt;
&lt;li&gt;深夜无聊，不如来陪我玩DDN：&lt;a href=&#34;https://ddnet.org/&#34;&gt;DDraceNetwork&lt;/a&gt;/&lt;a href=&#34;https://wiki.ddnet.org/&#34;&gt;wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;摸鱼大全：&lt;a href=&#34;https://blackwhite0601.github.io/About&#34;&gt;推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;打字练习：&lt;a href=&#34;https://www.keybr.com/&#34;&gt;Typing Practice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;奖项查询：&lt;a href=&#34;https://bytew.net/OIer/&#34;&gt;OIerDb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;颓废：&lt;a href=&#34;https://likexia.gitee.io/game/index.html#/&#34;&gt;Git游戏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;初赛复习：&lt;a href=&#34;https://www.luogu.com.cn/blog/luogu-yizhimengxin/chu-sai&#34;&gt;初赛汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;歌曲：&lt;a href=&#34;https://www.bilibili.com/video/BV1m4411x7uj&#34;&gt;OI版Lemon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;算法：&lt;a href=&#34;https://visualgo.net/zh&#34;&gt;算法演示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;强烈推荐：&lt;a href=&#34;https://kana.byha.top:444/login&#34;&gt;kana!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2048：&lt;a href=&#34;https://www.ak-ioi.com/apps/oi-2048/&#34;&gt;2048&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线音游：&lt;a href=&#34;https://www.beatstage.com/&#34;&gt;beatstage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;手速：&lt;a href=&#34;https://www.arealme.com/click-speed-test/cn/&#34;&gt;CPS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MC：&lt;a href=&#34;https://classic.minecraft.net/&#34;&gt;Classic MC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;UT牛逼：&lt;a href=&#34;https://sans.nyaasu.top/&#34;&gt;Sans Fight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;好玩：&lt;a href=&#34;http://cav2.maougame.com/&#34;&gt;卡牌冒险者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;画图：&lt;a href=&#34;https://csacademy.com/app/graph_editor/&#34;&gt;csacademy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">推荐</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/tu-de-ji-chong-cun-chu-fang-shi/"" data-c="
          &lt;h1 id=&#34;1邻接矩阵&#34;&gt;1.邻接矩阵&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190128175511539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcyMTQyMw==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;邻接矩阵是表示顶点之间相邻关系的矩阵。&lt;/p&gt;
&lt;p&gt;例如：用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a_{ij}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.716668em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;不为0时表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;有一条边（也可以用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a_{ij}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.716668em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;不为0时表示&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;有一条长度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a_{ij}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.716668em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的边）&lt;/p&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;int x,y,z;//无向图带权加边 
scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);
mp[x][y]=z;
mp[y][x]=z;

int x,y,z;//有向图带权加边 
scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);
mp[x][y]=z;

int x,y;//无向图无权加边 
scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
mp[x][y]=1;
mp[y][x]=1;

int x,y;//有向图无权加边 
scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
mp[x][y]=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;邻接矩阵的好处&#34;&gt;邻接矩阵的好处：&lt;/h3&gt;
&lt;p&gt;1.直观、简单、好理解&lt;/p&gt;
&lt;p&gt;2.方便检查任意一对定点间是否存在边&lt;/p&gt;
&lt;p&gt;3.方便找任一顶点的所有“邻接点”（有边直接相连的顶点）&lt;/p&gt;
&lt;p&gt;4.方便计算任一顶点的度&lt;/p&gt;
&lt;p&gt;对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度。&lt;/p&gt;
&lt;p&gt;对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度（或入度）。&lt;/p&gt;
&lt;h3 id=&#34;邻接矩阵的缺点&#34;&gt;邻接矩阵的缺点：&lt;/h3&gt;
&lt;p&gt;1.浪费空间（特别是在稀疏图中，有大量空余空间）&lt;/p&gt;
&lt;p&gt;2.浪费时间（要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。）&lt;/p&gt;
&lt;p&gt;所以我们需要下面这两个：&lt;/p&gt;
&lt;h1 id=&#34;2邻接表&#34;&gt;2.邻接表&lt;/h1&gt;
&lt;p&gt;图的邻接表存储方法是一种顺序分配与链式分配相结合的存储方法。&lt;/p&gt;
&lt;p&gt;在邻接表中，对图中每个顶点建立一个单链表，第i个单链表中的节点表示依附于顶点i的边（对有向图是以顶点i为尾的边）。每个单链表上附设一个表头节点。&lt;/p&gt;
&lt;p&gt;邻接表的特点如下：&lt;/p&gt;
&lt;p&gt;1.邻接表表示不唯一。这是因为在每个顶点对应的单链表中，各边节点的链接次序可以是任意的，取决于建立邻接表的算法以及边的输入次序。&lt;/p&gt;
&lt;p&gt;2.对于有n个顶点和e条边的无向图，其邻接表有n个顶点节点和2e个边节点。显然，在总的边数小于n(n-1)/2的情况下，邻接表比邻接矩阵要节省空间。&lt;/p&gt;
&lt;p&gt;3.对于无向图，邻接表的顶点i对应的第i个链表的边节点数目正好是顶点i的度。&lt;/p&gt;
&lt;p&gt;4.对于有向图，邻接表的顶点i对应的第i个链表的边节点数目仅仅是顶点i的出度。其入度为邻接表中所有adjvex域值为i的边节点数目。&lt;/p&gt;
&lt;h1 id=&#34;3链式前向星&#34;&gt;3.链式前向星&lt;/h1&gt;
&lt;h3 id=&#34;1-结构&#34;&gt;1. 结构&lt;/h3&gt;
&lt;p&gt;这里用两个东西：&lt;/p&gt;
&lt;p&gt;1 结构体数组edge存边，edge[i]表示第i条边,&lt;/p&gt;
&lt;p&gt;2 head[i]存以i为起点的第一条边(在edge中的下标)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct EDGE{
	int next;   //下一条边的存储下标(默认0) 
	int to;     //这条边的终点 
	int w;      //权值 
}edge[500010];
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2增边&#34;&gt;2.增边&lt;/h3&gt;
&lt;p&gt;若以点i为起点的边新增了一条，在edge中的下标为j.&lt;/p&gt;
&lt;p&gt;那么edge[j].next=head[i];然后head[i]=j.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即每次新加的边作为第一条边，最后倒序遍历&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
void Add(int u, int v, int w) {  //起点u, 终点v, 权值w 
	//cnt为边的计数，从1开始计 
	edge[++cnt].next = head[u];
	edge[cnt].w = w;
	edge[cnt].to = v;
	head[u] = cnt;    //第一条边为当前边 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-遍历&#34;&gt;3. 遍历&lt;/h3&gt;
&lt;p&gt;遍历以st为起点的边&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for(int i=head[st]; i!=0; i=edge[i].next)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;i开始为第一条边，每次指向下一条(以0为结束标志)  （若下标从0开始，next应初始化-1）&lt;/p&gt;
&lt;h1 id=&#34;然后就没有然后了&#34;&gt;然后就没有然后了...&lt;/h1&gt;
">图的几种存储方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yydcc-blog.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的博客呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多信息在&lt;a href=&#34;https://blackwhite0601.github.io/&#34;&gt;我的小站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;这是一个OIer的小博客，被你发现了QWQ&lt;/p&gt;
&lt;p&gt;一个大菜鸡呢&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;菜鸡OIer，坐标ZJ&lt;/p&gt;
&lt;p&gt;今年初三（更新时间2023）&lt;/p&gt;
&lt;p&gt;是一个OIer/音游人/二次元/车万人/刀客塔/爱马士&lt;/p&gt;
&lt;p&gt;2023考入西交大少年班&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;OI（其实好像大概已经AFO了）&lt;/p&gt;
&lt;p&gt;音游/MC/明日方舟/赛马娘&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://api.xecades.xyz/api?bg=255%2C255%2C255%2C255&amp;amp;img=1&amp;amp;quote=%E4%BB%8A%E5%A4%A9%E4%B9%9F%E8%A6%81%E5%8A%A0%E6%B2%B9%E5%93%A6%E3%83%BE%28%E2%97%8D%C2%B0%E2%88%87%C2%B0%E2%97%8D%29%EF%BE%89%EF%BE%9E&amp;amp;site=https%3A%2F%2Fblackwhite0601.github.io%2F&amp;amp;email=3267831737%40qq.com&amp;amp;qq=3267831737&amp;amp;zhihu=ForeverCC&amp;amp;github=blackwhite0601&amp;amp;wechat=%E5%BF%98%E4%BA%86%EF%BC%88%E7%AC%91%EF%BC%8C%E5%85%B6%E5%AE%9E%E6%98%AF%E5%9F%BA%E6%9C%AC%E4%B8%8D%E7%94%A8%EF%BC%89&amp;amp;luogu=ForeverCC&amp;amp;bilibili=%E4%B8%80%E5%8F%AAForeverCC&amp;amp;codeforces=chencheng0601&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas>
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<script type="text/javascript" src="/media/js/mouse/fireworks.js"></script>


  <script src="/media/js/cool.js"></script>



  <div class="snow-container"></div>
  <script src="/media/js/bg/snow.js"></script>


</html>